/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.30 from the
 * contents of main.xs. Do not edit this file, edit main.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "C:/local/Slic3r/build/xs/main.xs"
#include <cstring>
#include <cstdlib>
#include <ostream>
#include <sstream>
#include <libslic3r/GCodeSender.hpp>

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"
#undef do_open
#undef do_close
#ifdef __cplusplus
}
#endif

#ifdef _WIN32
	#undef XS_EXTERNAL
	#define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#endif /* MSVC */

#line 35 "C:/local/Slic3r/build/xs/XS.cpp"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 179 "C:/local/Slic3r/build/xs/XS.cpp"

/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp' from 'main.xs' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/MotionPlanner.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/MotionPlanner.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp' */


/* INCLUDE_COMMAND:  Including output of 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "Utils.hpp"

XS_EUPXS(XS_Slic3r_VERSION); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_VERSION)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 28 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        RETVAL = newSVpv(SLIC3R_VERSION, 0);
#line 296 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_BUILD); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_BUILD)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 34 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        RETVAL = newSVpv(SLIC3R_BUILD, 0);
#line 314 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_DEBUG_OUT_PATH_PREFIX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_DEBUG_OUT_PATH_PREFIX)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 40 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        RETVAL = newSVpv(SLIC3R_DEBUG_OUT_PATH_PREFIX, 0);
#line 332 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_FORK_NAME); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_FORK_NAME)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 46 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        RETVAL = newSVpv(SLIC3R_FORK_NAME, 0);
#line 350 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_set_logging_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_set_logging_level)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "level");
    {
	unsigned int	level = (unsigned int)SvUV(ST(0))
;
#line 53 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        Slic3r::set_logging_level(level);
#line 369 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r_trace); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_trace)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "level, message");
    {
	unsigned int	level = (unsigned int)SvUV(ST(0))
;
	char *	message = (char *)SvPV_nolen(ST(1))
;
#line 60 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        Slic3r::trace(level, message);
#line 388 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r_encode_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_encode_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	const char *	src = (const char *)SvPV_nolen(ST(0))
;
	std::string	RETVAL;
#line 66 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        RETVAL = Slic3r::encode_path(src);
#line 406 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_decode_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_decode_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	const char *	src = (const char *)SvPV_nolen(ST(0))
;
	std::string	RETVAL;
#line 73 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        RETVAL = Slic3r::decode_path(src);
#line 430 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_normalize_utf8_nfc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_normalize_utf8_nfc)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "src");
    {
	const char *	src = (const char *)SvPV_nolen(ST(0))
;
	std::string	RETVAL;
#line 80 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
        RETVAL = Slic3r::normalize_utf8_nfc(src);
#line 454 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_xspp_test_croak_hangs_on_strawberry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_xspp_test_croak_hangs_on_strawberry)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 86 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp"
    	try {
    		throw 1;
    	} catch (...) {
    		croak("xspp_test_croak_hangs_on_strawberry: exception catched\n");
    	}
#line 479 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/XS.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/TriangleMesh.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__TriangleMesh_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	TriangleMesh *	RETVAL;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      RETVAL = new TriangleMesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 516 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__TriangleMesh_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 563 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
     RETVAL = THIS; 
#line 593 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_ReadSTLFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_ReadSTLFile)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, input_file");
    {
	TriangleMesh *	THIS;
	char*	input_file = (char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::ReadSTLFile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->ReadSTLFile( input_file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 640 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_write_ascii); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_write_ascii)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	TriangleMesh *	THIS;
	char*	output_file = (char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::write_ascii() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 70 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->write_ascii( output_file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 679 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_write_binary); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_write_binary)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	TriangleMesh *	THIS;
	char*	output_file = (char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::write_binary() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 83 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->write_binary( output_file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 718 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_repair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_repair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::repair() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 96 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->repair();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 755 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_WriteOBJFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_WriteOBJFile)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	TriangleMesh *	THIS;
	char*	output_file = (char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::WriteOBJFile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->WriteOBJFile( output_file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 794 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	TriangleMesh *	THIS;
	float	factor = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 122 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 833 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_scale_xyz); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_scale_xyz)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, versor");
    {
	TriangleMesh *	THIS;
	Pointf3*	versor;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::scale_xyz() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(versor) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(versor) )) {
              versor = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("versor is not of type %s (got %s)", Slic3r::perl_class_name(versor), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::scale_xyz() -- versor is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 135 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
     THIS->scale(*versor); 
#line 876 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	TriangleMesh *	THIS;
	float	x = (float)SvNV(ST(1))
;
	float	y = (float)SvNV(ST(2))
;
	float	z = (float)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 140 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 919 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_x)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	TriangleMesh *	THIS;
	float	angle = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 153 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->rotate_x( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 958 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_y)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	TriangleMesh *	THIS;
	float	angle = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 166 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->rotate_y( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 997 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_z)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	TriangleMesh *	THIS;
	float	angle = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 179 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->rotate_z( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1036 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::mirror_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 192 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->mirror_x();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1073 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::mirror_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 205 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->mirror_y();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1110 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::mirror_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 218 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->mirror_z();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1147 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_align_to_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_align_to_origin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::align_to_origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 231 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->align_to_origin();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1184 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center");
    {
	TriangleMesh *	THIS;
	double	angle = (double)SvNV(ST(1))
;
	Point*	center;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(center) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(center) )) {
              center = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("center is not of type %s (got %s)", Slic3r::perl_class_name(center), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate() -- center is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 244 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->rotate( angle, center );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1237 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_split); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_split)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	TriangleMeshPtrs	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::split() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 257 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      RETVAL = THIS->split();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1275 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (TriangleMeshPtrs::iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, to_SV(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_merge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_merge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, mesh");
    {
	TriangleMesh *	THIS;
	TriangleMesh*	mesh;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::merge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(mesh) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(mesh) )) {
              mesh = (TriangleMesh *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("mesh is not of type %s (got %s)", Slic3r::perl_class_name(mesh), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::merge() -- mesh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 271 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
     THIS->merge(*mesh); 
#line 1332 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_horizontal_projection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_horizontal_projection)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	ExPolygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::horizontal_projection() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 276 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      RETVAL = THIS->horizontal_projection();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1370 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_convex_hull); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_convex_hull)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::convex_hull() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 290 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      RETVAL = THIS->convex_hull();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1422 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 304 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1468 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_center); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_center)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::center() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 318 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
     RETVAL = THIS->bounding_box().center(); 
#line 1506 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_facets_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_facets_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::facets_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 324 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      RETVAL = THIS->facets_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1553 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_reset_repair_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_reset_repair_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::reset_repair_stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 338 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    try {
      THIS->reset_repair_stats();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1591 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_ReadFromPerl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_ReadFromPerl)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, vertices, facets");
    {
	SV*	vertices = ST(1)
;
	SV*	facets = ST(2)
;
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::ReadFromPerl() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 355 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        stl_file &stl = THIS->stl;
        stl.error = 0;
        stl.stats.type = inmemory;

        // count facets and allocate memory
        AV* facets_av = (AV*)SvRV(facets);
        stl.stats.number_of_facets = av_len(facets_av)+1;
        stl.stats.original_num_facets = stl.stats.number_of_facets;
        stl_allocate(&stl);

        // read geometry
        AV* vertices_av = (AV*)SvRV(vertices);
        for (int i = 0; i < stl.stats.number_of_facets; i++) {
            AV* facet_av = (AV*)SvRV(*av_fetch(facets_av, i, 0));
            stl_facet facet;
            facet.normal.x = 0;
            facet.normal.y = 0;
            facet.normal.z = 0;
            for (unsigned int v = 0; v <= 2; v++) {
                AV* vertex_av = (AV*)SvRV(*av_fetch(vertices_av, SvIV(*av_fetch(facet_av, v, 0)), 0));
                facet.vertex[v].x = SvNV(*av_fetch(vertex_av, 0, 0));
                facet.vertex[v].y = SvNV(*av_fetch(vertex_av, 1, 0));
                facet.vertex[v].z = SvNV(*av_fetch(vertex_av, 2, 0));
            }
            facet.extra[0] = 0;
            facet.extra[1] = 0;

            stl.facet_start[i] = facet;
        }

        stl_get_size(&stl);
#line 1654 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 390 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        HV* hv = newHV();
        (void)hv_stores( hv, "number_of_facets",    newSViv(THIS->stl.stats.number_of_facets) );
        (void)hv_stores( hv, "number_of_parts",     newSViv(THIS->stl.stats.number_of_parts) );
        (void)hv_stores( hv, "volume",              newSVnv(THIS->stl.stats.volume) );
        (void)hv_stores( hv, "degenerate_facets",   newSViv(THIS->stl.stats.degenerate_facets) );
        (void)hv_stores( hv, "edges_fixed",         newSViv(THIS->stl.stats.edges_fixed) );
        (void)hv_stores( hv, "facets_removed",      newSViv(THIS->stl.stats.facets_removed) );
        (void)hv_stores( hv, "facets_added",        newSViv(THIS->stl.stats.facets_added) );
        (void)hv_stores( hv, "facets_reversed",     newSViv(THIS->stl.stats.facets_reversed) );
        (void)hv_stores( hv, "backwards_edges",     newSViv(THIS->stl.stats.backwards_edges) );
        (void)hv_stores( hv, "normals_fixed",       newSViv(THIS->stl.stats.normals_fixed) );
        RETVAL = (SV*)newRV_noinc((SV*)hv);
#line 1695 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_vertices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_vertices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::vertices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 408 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        if (!THIS->repaired) CONFESS("vertices() requires repair()");

        if (THIS->stl.v_shared == NULL)
            stl_generate_shared_vertices(&(THIS->stl));

        // vertices
        AV* vertices = newAV();
        av_extend(vertices, THIS->stl.stats.shared_vertices);
        for (int i = 0; i < THIS->stl.stats.shared_vertices; i++) {
            AV* vertex = newAV();
            av_store(vertices, i, newRV_noinc((SV*)vertex));
            av_extend(vertex, 2);
            av_store(vertex, 0, newSVnv(THIS->stl.v_shared[i].x));
            av_store(vertex, 1, newSVnv(THIS->stl.v_shared[i].y));
            av_store(vertex, 2, newSVnv(THIS->stl.v_shared[i].z));
        }

        RETVAL = newRV_noinc((SV*)vertices);
#line 1744 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_facets); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_facets)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::facets() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 432 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        if (!THIS->repaired) CONFESS("facets() requires repair()");

        if (THIS->stl.v_shared == NULL)
            stl_generate_shared_vertices(&(THIS->stl));

        // facets
        AV* facets = newAV();
        av_extend(facets, THIS->stl.stats.number_of_facets);
        for (int i = 0; i < THIS->stl.stats.number_of_facets; i++) {
            AV* facet = newAV();
            av_store(facets, i, newRV_noinc((SV*)facet));
            av_extend(facet, 2);
            av_store(facet, 0, newSVnv(THIS->stl.v_indices[i].vertex[0]));
            av_store(facet, 1, newSVnv(THIS->stl.v_indices[i].vertex[1]));
            av_store(facet, 2, newSVnv(THIS->stl.v_indices[i].vertex[2]));
        }

        RETVAL = newRV_noinc((SV*)facets);
#line 1793 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_normals); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_normals)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::normals() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 456 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        if (!THIS->repaired) CONFESS("normals() requires repair()");

        // normals
        AV* normals = newAV();
        av_extend(normals, THIS->stl.stats.number_of_facets);
        for (int i = 0; i < THIS->stl.stats.number_of_facets; i++) {
            AV* facet = newAV();
            av_store(normals, i, newRV_noinc((SV*)facet));
            av_extend(facet, 2);
            av_store(facet, 0, newSVnv(THIS->stl.facet_start[i].normal.x));
            av_store(facet, 1, newSVnv(THIS->stl.facet_start[i].normal.y));
            av_store(facet, 2, newSVnv(THIS->stl.facet_start[i].normal.z));
        }

        RETVAL = newRV_noinc((SV*)normals);
#line 1839 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 477 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        AV* size = newAV();
        av_extend(size, 2);
        av_store(size, 0, newSVnv(THIS->stl.stats.size.x));
        av_store(size, 1, newSVnv(THIS->stl.stats.size.y));
        av_store(size, 2, newSVnv(THIS->stl.stats.size.z));
        RETVAL = newRV_noinc((SV*)size);
#line 1876 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_slice)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	std::vector<double>	z;
	TriangleMesh *	THIS;
	SV *	RETVAL;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  z = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      z[i] = SvNV(*elem);
	    else
	      z[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::TriangleMesh::slice",
	             "z")
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::slice() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 490 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        // convert doubles to floats
        std::vector<float> z_f(z.begin(), z.end());

        std::vector<ExPolygons> layers;
        TriangleMeshSlicer mslicer(THIS);
        mslicer.slice(z_f, &layers);

        AV* layers_av = newAV();
        size_t len = layers.size();
        if (len > 0) av_extend(layers_av, len-1);
        for (unsigned int i = 0; i < layers.size(); i++) {
            AV* expolygons_av = newAV();
            len = layers[i].size();
            if (len > 0) av_extend(expolygons_av, len-1);
            unsigned int j = 0;
            for (ExPolygons::iterator it = layers[i].begin(); it != layers[i].end(); ++it) {
                av_store(expolygons_av, j++, perl_to_SV_clone_ref(*it));
            }
            av_store(layers_av, i, newRV_noinc((SV*)expolygons_av));
        }
        RETVAL = (SV*)newRV_noinc((SV*)layers_av);
#line 1948 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_cut); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_cut)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, z, upper, lower");
    {
	float	z = (float)SvNV(ST(1))
;
	TriangleMesh*	upper;
	TriangleMesh*	lower;
	TriangleMesh *	THIS;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(upper) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(upper) )) {
              upper = (TriangleMesh *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("upper is not of type %s (got %s)", Slic3r::perl_class_name(upper), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::cut() -- upper is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
        if ( sv_isa(ST(3), Slic3r::perl_class_name(lower) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(lower) )) {
              lower = (TriangleMesh *)SvIV((SV*)SvRV( ST(3) ));
        } else {
              croak("lower is not of type %s (got %s)", Slic3r::perl_class_name(lower), HvNAME(SvSTASH(SvRV(ST(3)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::cut() -- lower is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::cut() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 520 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        TriangleMeshSlicer mslicer(THIS);
        mslicer.cut(z, upper, lower);
#line 2010 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_bb3); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_bb3)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::bb3() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 526 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        RETVAL.push_back(THIS->stl.stats.min.x);
        RETVAL.push_back(THIS->stl.stats.min.y);
        RETVAL.push_back(THIS->stl.stats.max.x);
        RETVAL.push_back(THIS->stl.stats.max.y);
        RETVAL.push_back(THIS->stl.stats.min.z);
        RETVAL.push_back(THIS->stl.stats.max.z);
#line 2045 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_cube); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_cube)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "x, y, z");
    {
	Clone<TriangleMesh>	RETVAL;
	double	x = (double)SvNV(ST(0))
;
	double	y = (double)SvNV(ST(1))
;
	double	z = (double)SvNV(ST(2))
;
#line 539 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        RETVAL = make_cube(x,y,z);
#line 2081 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_cylinder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_cylinder)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "r, h");
    {
	Clone<TriangleMesh>	RETVAL;
	double	r = (double)SvNV(ST(0))
;
	double	h = (double)SvNV(ST(1))
;
#line 546 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        RETVAL = make_cylinder(r, h);
#line 2109 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_sphere); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_sphere)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "rho");
    {
	Clone<TriangleMesh>	RETVAL;
	double	rho = (double)SvNV(ST(0))
;
#line 553 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
        RETVAL = make_sphere(rho);
#line 2135 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_hello_world); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_hello_world)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	std::string	RETVAL;
#line 568 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp"
    RETVAL = "Hello world!";
#line 2159 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/TriangleMesh.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/SurfaceCollection.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Surface__Collection__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection__new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	SurfaceCollection *	RETVAL;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
    try {
      RETVAL = new SurfaceCollection();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2202 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Surface__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2249 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
     THIS->surfaces.clear(); 
#line 2278 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_append)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, surface");
    {
	SurfaceCollection *	THIS;
	Surface*	surface;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(surface) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(surface) )) {
              surface = (Surface *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("surface is not of type %s (got %s)", Slic3r::perl_class_name(surface), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::append() -- surface is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
     THIS->surfaces.push_back(*surface); 
#line 2321 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 61 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
     RETVAL = THIS->surfaces.size(); 
#line 2352 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__Collection_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	SurfaceCollection *	THIS;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 67 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
    try {
      THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2392 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
        AV* av = newAV();
        av_fill(av, THIS->surfaces.size()-1);
        int i = 0;
        for (Surfaces::iterator it = THIS->surfaces.begin(); it != THIS->surfaces.end(); ++it) {
            av_store(av, i++, perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 2428 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__Collection_filter_by_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_filter_by_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, surface_type");
    {
	SurfaceType	surface_type = (SurfaceType)SvUV(ST(1))
;
	SurfaceCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::filter_by_type() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 96 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
        AV* av = newAV();
        for (Surfaces::iterator it = THIS->surfaces.begin(); it != THIS->surfaces.end(); ++it) {
            if ((*it).surface_type == surface_type) av_push(av, perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 2466 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__Collection_replace); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_replace)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, index, surface");
    {
	int	index = (int)SvIV(ST(1))
;
	Surface*	surface;
	SurfaceCollection *	THIS;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(surface) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(surface) )) {
              surface = (Surface *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("surface is not of type %s (got %s)", Slic3r::perl_class_name(surface), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::replace() -- surface is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::replace() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
        THIS->surfaces[index] = *surface;
#line 2513 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_set_surface_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_set_surface_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, index, surface_type");
    {
	int	index = (int)SvIV(ST(1))
;
	SurfaceType	surface_type = (SurfaceType)SvUV(ST(2))
;
	SurfaceCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::set_surface_type() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 116 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
        THIS->surfaces[index].surface_type = surface_type;
#line 2546 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_group)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::group() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 121 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp"
        // perform grouping
        std::vector<SurfacesPtr> groups;
        THIS->group(&groups);

        // build return arrayref
        AV* av = newAV();
        av_fill(av, groups.size()-1);
        size_t i = 0;
        for (std::vector<SurfacesPtr>::iterator it = groups.begin(); it != groups.end(); ++it) {
            AV* innerav = newAV();
            av_fill(innerav, it->size()-1);
            size_t j = 0;
            for (SurfacesPtr::iterator it_s = it->begin(); it_s != it->end(); ++it_s) {
                av_store(innerav, j++, perl_to_SV_clone_ref(**it_s));
            }
            av_store(av, i++, newRV_noinc((SV*)innerav));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 2593 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/SurfaceCollection.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Surface.hpp"
#include "libslic3r/ClipperUtils.hpp"

XS_EUPXS(XS_Slic3r__Surface_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 19 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2642 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface_expolygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_expolygon)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	Ref<ExPolygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::expolygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 32 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
     RETVAL = &(THIS->expolygon); 
#line 2672 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExPolygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_thickness); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_thickness)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::thickness() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
     RETVAL = THIS->thickness; 
#line 2711 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_thickness_layers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_thickness_layers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	unsigned short	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::thickness_layers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
     RETVAL = THIS->thickness_layers; 
#line 2743 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_area); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_area)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::area() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 50 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
    try {
      RETVAL = THIS->area();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2783 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_solid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_solid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_solid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 64 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
    try {
      RETVAL = THIS->is_solid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2823 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_external); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_external)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_external() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 78 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
    try {
      RETVAL = THIS->is_external();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2863 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_internal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_internal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_internal() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 92 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
    try {
      RETVAL = THIS->is_internal();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2903 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_bottom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_bottom)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_bottom() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 106 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
    try {
      RETVAL = THIS->is_bottom();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2943 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_bridge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_bridge)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_bridge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 120 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
    try {
      RETVAL = THIS->is_bridge();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2983 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__new)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "CLASS, expolygon, surface_type, thickness, thickness_layers, bridge_angle, extra_perimeters");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExPolygon*	expolygon;
	SurfaceType	surface_type = (SurfaceType)SvUV(ST(2))
;
	double	thickness = (double)SvNV(ST(3))
;
	unsigned short	thickness_layers = (unsigned short)SvUV(ST(4))
;
	double	bridge_angle = (double)SvNV(ST(5))
;
	unsigned short	extra_perimeters = (unsigned short)SvUV(ST(6))
;
	Surface *	RETVAL;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(expolygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(expolygon) )) {
              expolygon = (ExPolygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("expolygon is not of type %s (got %s)", Slic3r::perl_class_name(expolygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::_new() -- expolygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 143 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
        RETVAL = new Surface (surface_type, *expolygon);
        RETVAL->thickness           = thickness;
        RETVAL->thickness_layers    = thickness_layers;
        RETVAL->bridge_angle        = bridge_angle;
        RETVAL->extra_perimeters    = extra_perimeters;
        // we don't delete expolygon here because it's referenced by a Perl SV
        // whose DESTROY will take care of destruction
#line 3032 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_surface_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_surface_type)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Surface *	THIS;
	SurfaceType	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::surface_type() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 156 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
        if (items > 1) {
            THIS->surface_type = (SurfaceType)SvUV(ST(1));
        }
        RETVAL = THIS->surface_type;
#line 3074 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_bridge_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_bridge_angle)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Surface *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::bridge_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 166 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
        if (items > 1) {
            THIS->bridge_angle = (double)SvNV(ST(1));
        }
        RETVAL = THIS->bridge_angle;
#line 3109 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_extra_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_extra_perimeters)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Surface *	THIS;
	unsigned short	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::extra_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 176 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
        if (items > 1) {
            THIS->extra_perimeters = (double)SvUV(ST(1));
        }
        RETVAL = THIS->extra_perimeters;
#line 3144 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_polygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_polygons)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::polygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 186 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
        RETVAL.push_back(THIS->expolygon.contour);
        for (Polygons::iterator it = THIS->expolygon.holes.begin(); it != THIS->expolygon.holes.end(); ++it) {
            RETVAL.push_back((*it));
        }
#line 3178 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_offset)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "THIS, delta, joinType = ClipperLib::jtMiter, miterLimit = 3");
    {
	const float	delta = (const float)SvNV(ST(1))
;
	ClipperLib::JoinType	joinType;
	double	miterLimit;
	Surface *	THIS;
	Surfaces	RETVAL;

	if (items < 3)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(2))
;
	}

	if (items < 4)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(3))
;
	}

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 199 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
        surfaces_append(RETVAL, offset_ex(THIS->expolygon, delta, joinType, miterLimit), *THIS);
#line 3240 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Surfaces::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 223 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp"
    RETVAL = ix;
#line 3272 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Surface.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Print.hpp"
#include "libslic3r/PlaceholderParser.hpp"

XS_EUPXS(XS_Slic3r__Print__State__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__State__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 31 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    RETVAL = ix;
#line 3301 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Region_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Region_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintRegion *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Region::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 43 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->config; 
#line 3332 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Region_print); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Region_print)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintRegion *	THIS;
	Ref<Print>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Region::print() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 49 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->print();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3378 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Print>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Region_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Region_flow)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "THIS, role, layer_height, bridge, first_layer, width, object");
    {
	PrintRegion *	THIS;
	Clone<Flow>	RETVAL;
	FlowRole	role = (FlowRole)SvUV(ST(1))
;
	double	layer_height = (double)SvNV(ST(2))
;
	bool	bridge = (bool)SvUV(ST(3))
;
	bool	first_layer = (bool)SvUV(ST(4))
;
	double	width = (double)SvNV(ST(5))
;
	PrintObject*	object;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Region::flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(6)) && (SvTYPE(SvRV(ST(6))) == SVt_PVMG) ) {
        if ( sv_isa(ST(6), Slic3r::perl_class_name(object) ) ||  sv_isa(ST(6), Slic3r::perl_class_name_ref(object) )) {
              object = (PrintObject *)SvIV((SV*)SvRV( ST(6) ));
        } else {
              croak("object is not of type %s (got %s)", Slic3r::perl_class_name(object), HvNAME(SvSTASH(SvRV(ST(6)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Region::flow() -- object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 63 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->flow(role, layer_height, bridge, first_layer, width, *object); 
#line 3440 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_add_region_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_add_region_volume)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, region_id, volume_id");
    {
	PrintObject *	THIS;
	int	region_id = (int)SvIV(ST(1))
;
	int	volume_id = (int)SvIV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_region_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->add_region_volume( region_id, volume_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3489 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_get_region_volumes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_get_region_volumes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, region_id");
    {
	PrintObject *	THIS;
	std::vector<int>	RETVAL;
	int	region_id = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::get_region_volumes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 86 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
            if (0 <= region_id && region_id < THIS->region_volumes.size())
                RETVAL = THIS->region_volumes[region_id];
#line 3522 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_region_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_region_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::region_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 93 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->print()->regions.size(); 
#line 3567 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_print); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_print)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<Print>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::print() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 99 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->print();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3606 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Print>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_model_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_model_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<ModelObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::model_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 113 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->model_object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3652 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 127 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->config; 
#line 3690 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_copies)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Points	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 133 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->copies();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3736 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_layer_height_ranges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_layer_height_ranges)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	t_layer_height_ranges	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::layer_height_ranges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 147 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->layer_height_ranges; 
#line 3780 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
    // map is sorted, so we can just copy it in order
    int i = 0;
    for (t_layer_height_ranges::iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    const coordf_t range_values[] = {
		    it->first.first,    // key's first = minz
		    it->first.second,   // key's second = maxz
		    it->second,	 // value = height
		};
	    AV *rangeAV = newAV();
	    av_extend(rangeAV, 2);
	    for (int j = 0; j < 3; ++j) {
		av_store(rangeAV, j, newSVnv(range_values[j]));
	    }
	    av_store(av, i++, (SV*)newRV_noinc((SV*)rangeAV));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_layer_height_profile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_layer_height_profile)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::layer_height_profile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 153 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->layer_height_profile; 
#line 3835 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<Point3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 159 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->size; 
#line 3879 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 165 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3925 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object__shifted_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__shifted_copies)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Points	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_shifted_copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 179 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->_shifted_copies; 
#line 3963 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_shifted_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_shifted_copies)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	PrintObject *	THIS;
	Points	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_shifted_copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        value.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &value[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Print::Object::set_shifted_copies",
	             "value")
;
#line 185 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     THIS->_shifted_copies = value; 
#line 4021 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_add_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_add_copy)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_copy() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_copy() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 190 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->add_copy(*point); 
#line 4066 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_delete_last_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_delete_last_copy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::delete_last_copy() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 196 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->delete_last_copy();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4106 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_delete_all_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_delete_all_copies)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::delete_all_copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 210 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->delete_all_copies();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4146 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_copies)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, copies");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	Points	copies;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        copies.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &copies[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Print::Object::set_copies",
	             "copies")
;
#line 224 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->set_copies( copies );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4201 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_reload_model_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_reload_model_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::reload_model_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 238 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->reload_model_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4241 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_layer_height_ranges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_layer_height_ranges)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer_height_ranges");
    {
	PrintObject *	THIS;
	t_layer_height_ranges	layer_height_ranges;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_layer_height_ranges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
        if (!SvROK(ST(1)) || SvTYPE(SvRV(ST(1))) != SVt_PVAV) {
            Perl_croak(aTHX_ "%s: %s is not an array reference",
                     "Slic3r::Print::Object::set_layer_height_ranges",
                     "layer_height_ranges");
        }
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        t_layer_height_ranges tmp_ranges;
        for (unsigned int i = 0; i < len; i++) {
            SV* elem = *av_fetch(av, i, 0);
            if (!SvROK(elem) || SvTYPE(SvRV(elem)) != SVt_PVAV) {
                Perl_croak(
                    aTHX_ "%s: %s contains something that is not an array reference",
                        "Slic3r::Print::Object::set_layer_height_ranges",
                        "layer_height_ranges");
            }
            AV* elemAV = (AV*)SvRV(elem);
            if (av_len(elemAV) + 1 != 3) {
                Perl_croak(
                    aTHX_ "%s: %s contains an array that isn't 3 elements long",
                        "Slic3r::Print::Object::set_layer_height_ranges",
                        "layer_height_ranges");
            }
            coordf_t vals[3];
            for (unsigned int j = 0; j < 3; ++j) {
                SV *elem_elem = *av_fetch(elemAV, j, 0);
                if (!looks_like_number(elem_elem)) {
                    Perl_croak(
                        aTHX_ "%s: layer ranges and heights must be numbers",
                            "Slic3r::Print::Object::set_layer_height_ranges");
                }
                vals[j] = SvNV(elem_elem);
            }
            tmp_ranges[t_layer_height_range(vals[0], vals[1])] = vals[2];
        }
        layer_height_ranges = tmp_ranges;
    }
;
#line 252 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     THIS->layer_height_ranges = layer_height_ranges; 
#line 4312 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_set_layer_height_profile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_layer_height_profile)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, profile");
    {
	PrintObject *	THIS;
	std::vector< double >	profile;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_layer_height_profile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  profile = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      profile[i] = SvNV(*elem);
	    else
	      profile[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Print::Object::set_layer_height_profile",
	             "profile")
;
#line 257 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     THIS->layer_height_profile = profile; 
#line 4361 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_total_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_total_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::total_layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 262 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->total_layer_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4400 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 276 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->layer_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4440 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_clear_layers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_clear_layers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::clear_layers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 290 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->clear_layers();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4478 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_get_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_get_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	PrintObject *	THIS;
	Ref<Layer>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::get_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 303 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->get_layer( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4518 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_add_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_add_layer)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "THIS, id, height, print_z, slice_z");
    {
	PrintObject *	THIS;
	Ref<Layer>	RETVAL;
	int	id = (int)SvIV(ST(1))
;
	coordf_t	height = (coordf_t)SvNV(ST(2))
;
	coordf_t	print_z = (coordf_t)SvNV(ST(3))
;
	coordf_t	slice_z = (coordf_t)SvNV(ST(4))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 317 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->add_layer( id, height, print_z, slice_z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4572 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_support_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_support_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::support_layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 331 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->support_layer_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4619 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_clear_support_layers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_clear_support_layers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::clear_support_layers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 345 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->clear_support_layers();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4657 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_get_support_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_get_support_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	PrintObject *	THIS;
	Ref<SupportLayer>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::get_support_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 358 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->get_support_layer( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4697 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_add_support_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_add_support_layer)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, id, height, print_z");
    {
	PrintObject *	THIS;
	Ref<SupportLayer>	RETVAL;
	int	id = (int)SvIV(ST(1))
;
	coordf_t	height = (coordf_t)SvNV(ST(2))
;
	coordf_t	print_z = (coordf_t)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_support_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 372 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->add_support_layer( id, height, print_z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4749 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 386 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->state.is_done(step); 
#line 4790 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	PrintObject *	THIS;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 392 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     THIS->state.set_done(step); 
#line 4822 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_set_step_started); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_step_started)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	PrintObject *	THIS;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_step_started() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 397 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     THIS->state.set_started(step); 
#line 4853 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__slice)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_slice() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 402 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_slice();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4890 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__fix_slicing_errors); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__fix_slicing_errors)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_fix_slicing_errors() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 415 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->_fix_slicing_errors();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4928 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object__simplify_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__simplify_slices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	PrintObject *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_simplify_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 429 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_simplify_slices( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4973 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__prepare_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__prepare_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_prepare_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 442 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_prepare_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5010 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_detect_surfaces_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_detect_surfaces_type)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::detect_surfaces_type() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 455 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->detect_surfaces_type();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5047 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_process_external_surfaces); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_process_external_surfaces)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::process_external_surfaces() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 468 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->process_external_surfaces();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5084 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__make_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__make_perimeters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_make_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 481 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_make_perimeters();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5121 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 494 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5158 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__generate_support_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__generate_support_material)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_generate_support_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 507 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_generate_support_material();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5195 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_get_layer_height_min_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_get_layer_height_min_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::get_layer_height_min_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 520 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
            SlicingParameters slicing_params = THIS->slicing_parameters();
            RETVAL.push_back(slicing_params.min_layer_height);
            RETVAL.push_back(slicing_params.max_layer_height);
            RETVAL.push_back(slicing_params.first_print_layer_height);
            RETVAL.push_back(slicing_params.first_object_layer_height);
            RETVAL.push_back(slicing_params.layer_height);
#line 5230 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_adjust_layer_height_profile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_adjust_layer_height_profile)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "THIS, z, layer_thickness_delta, band_width, action");
    {
	PrintObject *	THIS;
	coordf_t	z = (coordf_t)SvNV(ST(1))
;
	coordf_t	layer_thickness_delta = (coordf_t)SvNV(ST(2))
;
	coordf_t	band_width = (coordf_t)SvNV(ST(3))
;
	int	action = (int)SvIV(ST(4))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::adjust_layer_height_profile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 531 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
            THIS->update_layer_height_profile(THIS->model_object()->layer_height_profile);
            adjust_layer_height_profile(
                THIS->slicing_parameters(), THIS->model_object()->layer_height_profile, z, layer_thickness_delta, band_width, LayerHeightEditActionType(action));
            THIS->model_object()->layer_height_profile_valid = true;
            THIS->layer_height_profile_valid = false;
#line 5285 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_reset_layer_height_profile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_reset_layer_height_profile)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::reset_layer_height_profile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 540 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->reset_layer_height_profile();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5322 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_ptr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_ptr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::ptr() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 553 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = (int)(intptr_t)THIS; 
#line 5353 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Print_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Print *	RETVAL;
#line 565 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = new Print();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5382 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Print_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 582 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5429 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 595 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->config; 
#line 5459 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_default_object_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_default_object_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::default_object_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 601 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->default_object_config; 
#line 5497 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_default_region_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_default_region_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::default_region_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 607 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->default_region_config; 
#line 5535 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_placeholder_parser); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_placeholder_parser)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<PlaceholderParser>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::placeholder_parser() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 613 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->placeholder_parser; 
#line 5573 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PlaceholderParser>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_skirt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_skirt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::skirt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 620 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->skirt; 
#line 5611 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_brim); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_brim)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::brim() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 626 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->brim; 
#line 5649 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_objects)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	PrintObjectPtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 632 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->objects; 
#line 5687 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (PrintObjectPtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_clear_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_clear_objects)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::clear_objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 638 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->clear_objects();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5738 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_get_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_get_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Print *	THIS;
	Ref<PrintObject>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::get_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 651 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->get_object( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5778 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_delete_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_delete_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Print *	THIS;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::delete_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 665 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->delete_object( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5825 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_reload_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_reload_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Print *	THIS;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::reload_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 678 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->reload_object( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5864 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_reload_model_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_reload_model_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::reload_model_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 691 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->reload_model_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5903 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_object_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_object_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::object_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 705 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->objects.size(); 
#line 5935 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_regions); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_regions)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	PrintRegionPtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::regions() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 711 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = &THIS->regions; 
#line 5966 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (PrintRegionPtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_get_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_get_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Print *	THIS;
	Ref<PrintRegion>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::get_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 717 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->get_region( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6020 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_add_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_add_region)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<PrintRegion>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::add_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 731 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->add_region();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6066 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_region_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_region_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::region_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 745 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->regions.size(); 
#line 6105 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;
	PrintStep	step = (PrintStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 751 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->state.is_done(step); 
#line 6139 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_object_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_object_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::object_step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 757 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->step_done(step); 
#line 6173 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_set_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_set_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	PrintStep	step = (PrintStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::set_step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 763 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     THIS->state.set_done(step); 
#line 6205 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_set_step_started); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_set_step_started)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	PrintStep	step = (PrintStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::set_step_started() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 768 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     THIS->state.set_started(step); 
#line 6236 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_clear_filament_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_clear_filament_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::clear_filament_stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 773 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
            THIS->filament_stats.clear();
#line 6265 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_set_filament_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_set_filament_stats)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, extruder_id, length");
    {
	Print *	THIS;
	int	extruder_id = (int)SvIV(ST(1))
;
	float	length = (float)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::set_filament_stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 778 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
            THIS->filament_stats.insert(std::pair<size_t,float>(extruder_id, 0));
            THIS->filament_stats[extruder_id] += length;
#line 6299 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_filament_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_filament_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::filament_stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 784 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
            HV* hv = newHV();
            for (std::map<size_t,float>::const_iterator it = THIS->filament_stats.begin(); it != THIS->filament_stats.end(); ++it) {
                // stringify extruder_id
                std::ostringstream ss;
                ss << it->first;
                std::string str = ss.str();
                (void)hv_store( hv, str.c_str(), str.length(), newSViv(it->second), 0 );
                RETVAL = newRV_noinc((SV*)hv);
            }
#line 6337 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__simplify_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__simplify_slices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Print *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_simplify_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 798 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_simplify_slices( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6378 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_max_allowed_layer_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_max_allowed_layer_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::max_allowed_layer_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 811 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->max_allowed_layer_height();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6417 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_has_support_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_has_support_material)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::has_support_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 825 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->has_support_material();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6457 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_auto_assign_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_auto_assign_extruders)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, model_object");
    {
	Print *	THIS;
	ModelObject*	model_object;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::auto_assign_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(model_object) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(model_object) )) {
              model_object = (ModelObject *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("model_object is not of type %s (got %s)", Slic3r::perl_class_name(model_object), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::auto_assign_extruders() -- model_object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 839 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->auto_assign_extruders( model_object );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6509 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_output_filename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_output_filename)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::output_filename() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 852 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->output_filename();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6547 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_output_filepath); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_output_filepath)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, path= \"\"");
    {
	Print *	THIS;
	std::string	RETVAL;
	std::string	path;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::output_filepath() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    path = "";
	else {
    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      path = std::string(c, len);
    }
;
	}
#line 866 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->output_filepath( path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6605 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_add_model_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_add_model_object)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, model_object, idx= -1");
    {
	Print *	THIS;
	ModelObject*	model_object;
	int	idx;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::add_model_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(model_object) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(model_object) )) {
              model_object = (ModelObject *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("model_object is not of type %s (got %s)", Slic3r::perl_class_name(model_object), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::add_model_object() -- model_object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    idx = -1;
	else {
	    idx = (int)SvIV(ST(2))
;
	}
#line 880 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->add_model_object( model_object, idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6670 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_apply_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_apply_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, config");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;
	DynamicPrintConfig*	config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::apply_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(config) )) {
              config = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("config is not of type %s (got %s)", Slic3r::perl_class_name(config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::apply_config() -- config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 893 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->apply_config(*config); 
#line 6715 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_has_infinite_skirt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_has_infinite_skirt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::has_infinite_skirt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 899 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->has_infinite_skirt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6755 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_has_skirt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_has_skirt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::has_skirt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 913 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->has_skirt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6795 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_extruders)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	std::vector<unsigned int>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 927 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->extruders();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6834 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVuv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__validate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__validate)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_validate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 941 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
     RETVAL = THIS->validate(); 
#line 6878 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 947 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6922 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_total_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 961 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->total_bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6968 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_skirt_first_layer_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_skirt_first_layer_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::skirt_first_layer_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 975 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->skirt_first_layer_height();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7015 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_brim_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_brim_flow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Clone<Flow>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::brim_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 989 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->brim_flow();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7054 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_skirt_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_skirt_flow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Clone<Flow>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::skirt_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1003 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->skirt_flow();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7100 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__make_skirt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__make_skirt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_make_skirt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1017 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_make_skirt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7145 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__make_brim); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__make_brim)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_make_brim() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1030 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_make_brim();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7182 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_has_wipe_tower); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_has_wipe_tower)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::has_wipe_tower() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1043 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      RETVAL = THIS->has_wipe_tower();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7221 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__clear_wipe_tower); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__clear_wipe_tower)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_clear_wipe_tower() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1057 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_clear_wipe_tower();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7259 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__make_wipe_tower); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__make_wipe_tower)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_make_wipe_tower() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1070 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
    try {
      THIS->_make_wipe_tower();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7296 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_total_used_filament); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_used_filament)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_used_filament() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1085 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
        if (items > 1) {
            THIS->total_used_filament = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_used_filament;
#line 7330 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_total_extruded_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_extruded_volume)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_extruded_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1095 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
        if (items > 1) {
            THIS->total_extruded_volume = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_extruded_volume;
#line 7365 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_total_weight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_weight)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_weight() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1106 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
        if (items > 1) {
            THIS->total_weight = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_weight;
#line 7400 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_total_cost); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_cost)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_cost() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1116 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp"
        if (items > 1) {
            THIS->total_cost = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_cost;
#line 7435 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Print.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/PolylineCollection.hpp"

XS_EUPXS(XS_Slic3r__Polyline__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7482 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	Clone<PolylineCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
     RETVAL = THIS; 
#line 7512 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<PolylineCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 37 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
     THIS->polylines.clear(); 
#line 7549 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_chained_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_chained_path)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, no_reverse");
    {
	PolylineCollection *	THIS;
	PolylineCollection *	RETVAL;
	bool	no_reverse = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::chained_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 42 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
            RETVAL = new PolylineCollection();
            THIS->chained_path(RETVAL, no_reverse);
#line 7582 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_chained_path_from); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_chained_path_from)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, start_near, no_reverse");
    {
	PolylineCollection *	THIS;
	PolylineCollection *	RETVAL;
	Point*	start_near;
	bool	no_reverse = (bool)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::chained_path_from() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(start_near) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(start_near) )) {
              start_near = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("start_near is not of type %s (got %s)", Slic3r::perl_class_name(start_near), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::chained_path_from() -- start_near is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 49 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
            RETVAL = new PolylineCollection();
            THIS->chained_path_from(*start_near, RETVAL, no_reverse);
#line 7637 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
     RETVAL = THIS->polylines.size(); 
#line 7676 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_leftmost_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_leftmost_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::leftmost_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
    try {
      RETVAL = THIS->leftmost_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7715 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PolylineCollection *	RETVAL;
#line 78 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
        RETVAL = new PolylineCollection ();
        // ST(0) is class name, others are Polylines
        RETVAL->polylines.resize(items-1);
        for (unsigned int i = 1; i < items; i++) {
            // Note: a COPY of the input is stored
            from_SV_check(ST(i), &RETVAL->polylines[i-1]);
        }
#line 7747 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
        AV* av = newAV();
        av_fill(av, THIS->polylines.size()-1);
        int i = 0;
        for (Polylines::iterator it = THIS->polylines.begin(); it != THIS->polylines.end(); ++it) {
            av_store(av, i++, perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 7791 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 104 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
        AV* av = newAV();
        av_fill(av, THIS->polylines.size()-1);
        int i = 0;
        for (Polylines::iterator it = THIS->polylines.begin(); it != THIS->polylines.end(); ++it) {
            av_store(av, i++, to_SV_pureperl(&*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 7829 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PolylineCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 117 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp"
        for (unsigned int i = 1; i < items; i++) {
            Polyline polyline;
            from_SV_check(ST(i), &polyline);
            THIS->polylines.push_back(polyline);
        }
#line 7864 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PolylineCollection.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/BoundingBox.hpp"
#include "libslic3r/ClipperUtils.hpp"
#include "libslic3r/Polyline.hpp"

XS_EUPXS(XS_Slic3r__Polyline_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 20 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7912 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 33 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
     RETVAL = THIS; 
#line 7942 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
     RETVAL = to_AV(THIS); 
#line 7980 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 45 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
     RETVAL = to_SV_pureperl(THIS); 
#line 8012 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Polyline *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8053 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Polyline *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 64 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8094 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_pop_back); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_pop_back)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::pop_back() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
     THIS->points.pop_back(); 
#line 8123 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8160 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_lines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_lines)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Lines	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::lines() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 95 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->lines();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8198 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Lines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8250 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 123 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8296 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_equally_spaced_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_equally_spaced_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	Points	RETVAL;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::equally_spaced_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 137 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->equally_spaced_points( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8344 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 151 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8397 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::is_valid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 165 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->is_valid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8437 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_clip_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_clip_end)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::clip_end() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 179 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->clip_end( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8477 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_clip_start); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_clip_start)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::clip_start() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 192 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->clip_start( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8516 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_extend_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_extend_end)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::extend_end() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 205 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->extend_end( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8555 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_extend_start); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_extend_start)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::extend_start() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 218 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->extend_start( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8594 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	Polyline *	THIS;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 231 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8633 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_simplify_by_visibility); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_simplify_by_visibility)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, expolygon");
    {
	Polyline *	THIS;
	ExPolygon*	expolygon;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::simplify_by_visibility() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(expolygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(expolygon) )) {
              expolygon = (ExPolygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("expolygon is not of type %s (got %s)", Slic3r::perl_class_name(expolygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::simplify_by_visibility() -- expolygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 244 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
     THIS->simplify_by_visibility(*expolygon); 
#line 8676 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_split_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_split_at)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, point, p1, p2");
    {
	Polyline *	THIS;
	Point*	point;
	Polyline*	p1;
	Polyline*	p2;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::split_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::split_at() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(p1) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(p1) )) {
              p1 = (Polyline *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("p1 is not of type %s (got %s)", Slic3r::perl_class_name(p1), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::split_at() -- p1 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
        if ( sv_isa(ST(3), Slic3r::perl_class_name(p2) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(p2) )) {
              p2 = (Polyline *)SvIV((SV*)SvRV( ST(3) ));
        } else {
              croak("p2 is not of type %s (got %s)", Slic3r::perl_class_name(p2), HvNAME(SvSTASH(SvRV(ST(3)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::split_at() -- p2 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 249 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
     THIS->split_at(*point, p1, p2); 
#line 8747 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_is_straight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_is_straight)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::is_straight() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 254 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->is_straight();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8786 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 268 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8825 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_remove_duplicate_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_remove_duplicate_points)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::remove_duplicate_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 282 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      THIS->remove_duplicate_points();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8870 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_wkt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_wkt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::wkt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 295 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
    try {
      RETVAL = THIS->wkt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8908 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Polyline *	RETVAL;
#line 311 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
        RETVAL = new Polyline ();
        // ST(0) is class name, ST(1) is first point
        RETVAL->points.resize(items-1);
        for (unsigned int i = 1; i < items; i++) {
            from_SV_check(ST(i), &RETVAL->points[i-1]);
        }
#line 8937 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 323 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
        for (unsigned int i = 1; i < items; i++) {
            Point p;
            from_SV_check(ST(i), &p);
            THIS->points.push_back(p);
        }
#line 8978 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_append_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_append_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	Polyline*	polyline;
	Polyline *	THIS;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::append_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::append_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 333 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
        for (Points::const_iterator it = polyline->points.begin(); it != polyline->points.end(); ++it) {
            THIS->points.push_back((*it));
        }
#line 9023 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 342 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 9058 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_grow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_grow)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "THIS, delta, joinType = ClipperLib::jtSquare, miterLimit = 3");
    {
	const float	delta = (const float)SvNV(ST(1))
;
	ClipperLib::JoinType	joinType;
	double	miterLimit;
	Polyline *	THIS;
	Polygons	RETVAL;

	if (items < 3)
	    joinType = ClipperLib::jtSquare;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(2))
;
	}

	if (items < 4)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(3))
;
	}

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::grow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 352 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp"
        RETVAL = offset(*THIS, delta, joinType, miterLimit);
#line 9106 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polyline.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/BoundingBox.hpp"
#include "libslic3r/Polygon.hpp"
#include "libslic3r/BoundingBox.hpp"

XS_EUPXS(XS_Slic3r__Polygon_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 20 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9168 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polygon_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 33 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
     RETVAL = THIS; 
#line 9198 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
     RETVAL = to_AV(THIS); 
#line 9236 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 45 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
     RETVAL = to_SV_pureperl(THIS); 
#line 9268 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Polygon *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9309 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polygon_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Polygon *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 64 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9350 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polygon_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9387 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polygon_lines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_lines)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Lines	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::lines() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 90 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->lines();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9425 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Lines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_split_at_vertex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_split_at_vertex)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Polygon *	THIS;
	Clone<Polyline>	RETVAL;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::split_at_vertex() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::split_at_vertex() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 104 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
     RETVAL = THIS->split_at_vertex(*point); 
#line 9483 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_split_at_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_split_at_index)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, index");
    {
	Polygon *	THIS;
	Clone<Polyline>	RETVAL;
	int	index = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::split_at_index() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 110 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->split_at_index( index );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9531 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_split_at_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_split_at_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::split_at_first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 124 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->split_at_first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9577 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_equally_spaced_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_equally_spaced_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polygon *	THIS;
	Points	RETVAL;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::equally_spaced_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 138 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->equally_spaced_points( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9625 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 152 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9678 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_area); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_area)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::area() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 166 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->area();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9718 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_is_counter_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_is_counter_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::is_counter_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 180 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->is_counter_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9758 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_is_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_is_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::is_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 194 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->is_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9798 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_make_counter_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_make_counter_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::make_counter_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 208 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->make_counter_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9838 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_make_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_make_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::make_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 222 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->make_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9878 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::is_valid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 236 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->is_valid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9918 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 250 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9957 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 264 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
     RETVAL = THIS->contains(*point); 
#line 10010 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	Polygon *	THIS;
	Polygons	RETVAL;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 270 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10051 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_triangulate_convex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_triangulate_convex)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::triangulate_convex() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 284 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
     THIS->triangulate_convex(&RETVAL); 
#line 10095 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_centroid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_centroid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::centroid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 290 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->centroid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10147 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 304 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10193 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_wkt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_wkt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::wkt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 318 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->wkt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10239 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_concave_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_concave_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	Polygon *	THIS;
	Points	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::concave_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 332 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->concave_points( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10285 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_convex_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_convex_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	Polygon *	THIS;
	Points	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::convex_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 346 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
    try {
      RETVAL = THIS->convex_points( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10339 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_point_projection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_point_projection)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Polygon *	THIS;
	Clone<Point>	RETVAL;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::point_projection() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::point_projection() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 360 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
     RETVAL = THIS->point_projection(*point); 
#line 10397 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_intersection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_intersection)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Polygon *	THIS;
	Clone<Point>	RETVAL;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::intersection() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::intersection() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 366 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
            Point p;
            (void)THIS->intersection(*line, &p);
            RETVAL = p;
#line 10451 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_first_intersection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_first_intersection)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Polygon *	THIS;
	Clone<Point>	RETVAL;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::first_intersection() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::first_intersection() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 374 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
            Point p;
            (void)THIS->first_intersection(*line, &p);
            RETVAL = p;
#line 10505 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Polygon *	RETVAL;
#line 384 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
        RETVAL = new Polygon ();
        // ST(0) is class name, ST(1) is first point
        RETVAL->points.resize(items-1);
        for (unsigned int i = 1; i < items; i++) {
            from_SV_check(ST(i), &RETVAL->points[i-1]);
        }
#line 10536 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	Polygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 398 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp"
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 10579 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Polygon.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Point.hpp"
#include "libslic3r/Polygon.hpp"
#include "libslic3r/Polyline.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Point_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "CLASS, _x= 0, _y= 0");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Point *	RETVAL;
	long	_x;
	long	_y;

	if (items < 2)
	    _x = 0;
	else {
	    _x = (long)SvIV(ST(1))
;
	}

	if (items < 3)
	    _y = 0;
	else {
	    _y = (long)SvIV(ST(2))
;
	}
#line 23 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      RETVAL = new Point( _x, _y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10634 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Point_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 40 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10681 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 53 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL=THIS; 
#line 10711 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Point *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 59 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10758 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Point *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 72 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10799 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 85 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = to_SV_pureperl(THIS); 
#line 10829 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = to_SV_pureperl(THIS); 
#line 10861 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 97 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->x; 
#line 10894 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 103 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->y; 
#line 10926 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_set_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_set_x)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Point *	THIS;
	long	val = (long)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::set_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     THIS->x = val; 
#line 10958 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_set_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_set_y)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Point *	THIS;
	long	val = (long)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::set_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 114 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     THIS->y = val; 
#line 10989 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_nearest_point_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_nearest_point_index)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, points");
    {
	Point *	THIS;
	int	RETVAL;
	dXSTARG;
	Points	points;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::nearest_point_index() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Point::nearest_point_index",
	             "points")
;
#line 119 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      RETVAL = THIS->nearest_point_index( points );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11043 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_nearest_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_nearest_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, points");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;
	Points	points;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::nearest_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Point::nearest_point",
	             "points")
;
#line 133 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     Point p; THIS->nearest_point(points, &p); RETVAL = p; 
#line 11089 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_distance_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_distance_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::distance_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::distance_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 139 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->distance_to(*point); 
#line 11142 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_distance_to_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_distance_to_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::distance_to_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::distance_to_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 145 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->distance_to(*line); 
#line 11188 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_perp_distance_to_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_perp_distance_to_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::perp_distance_to_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::perp_distance_to_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 151 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->perp_distance_to(*line); 
#line 11234 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_ccw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_ccw)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, p1, p2");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Point*	p1;
	Point*	p2;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(p1) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(p1) )) {
              p1 = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("p1 is not of type %s (got %s)", Slic3r::perl_class_name(p1), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw() -- p1 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(p2) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(p2) )) {
              p2 = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("p2 is not of type %s (got %s)", Slic3r::perl_class_name(p2), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw() -- p2 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 157 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->ccw(*p1, *p2); 
#line 11294 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_ccw_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_ccw_angle)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, p1, p2");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Point*	p1;
	Point*	p2;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(p1) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(p1) )) {
              p1 = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("p1 is not of type %s (got %s)", Slic3r::perl_class_name(p1), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw_angle() -- p1 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(p2) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(p2) )) {
              p2 = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("p2 is not of type %s (got %s)", Slic3r::perl_class_name(p2), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw_angle() -- p2 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 163 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->ccw_angle(*p1, *p2); 
#line 11354 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_projection_onto_polygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_projection_onto_polygon)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polygon");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;
	Polygon*	polygon;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_polygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polygon) )) {
              polygon = (Polygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polygon is not of type %s (got %s)", Slic3r::perl_class_name(polygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_polygon() -- polygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 169 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = new Point(THIS->projection_onto(*polygon)); 
#line 11399 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_projection_onto_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_projection_onto_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 175 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = new Point(THIS->projection_onto(*polyline)); 
#line 11451 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_projection_onto_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_projection_onto_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 181 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = new Point(THIS->projection_onto(*line)); 
#line 11503 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_negative); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_negative)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::negative() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 187 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = new Point(THIS->negative()); 
#line 11541 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_coincides_with_epsilon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_coincides_with_epsilon)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Point *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::coincides_with_epsilon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::coincides_with_epsilon() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 193 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->coincides_with_epsilon(*point); 
#line 11594 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_serialize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 199 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     char buf[2048]; sprintf(buf, "%ld,%ld", THIS->x, THIS->y); RETVAL = buf; 
#line 11625 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	Point *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 209 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 11666 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_coincides_with); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_coincides_with)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point_sv");
    {
	SV*	point_sv = ST(1)
;
	Point *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::coincides_with() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 217 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
        Point point;
        from_SV_check(point_sv, &point);
        RETVAL = THIS->coincides_with(point);
#line 11701 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Point3_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 4)
       croak_xs_usage(cv,  "CLASS, _x= 0, _y= 0, _z= 0");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Point3 *	RETVAL;
	long	_x;
	long	_y;
	long	_z;

	if (items < 2)
	    _x = 0;
	else {
	    _x = (long)SvIV(ST(1))
;
	}

	if (items < 3)
	    _y = 0;
	else {
	    _y = (long)SvIV(ST(2))
;
	}

	if (items < 4)
	    _z = 0;
	else {
	    _z = (long)SvIV(ST(3))
;
	}
#line 234 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      RETVAL = new Point3( _x, _y, _z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11754 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Point3_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 251 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11801 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point3_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	Clone<Point3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 264 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS; 
#line 11831 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point3_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 270 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->x; 
#line 11870 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point3_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 276 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->y; 
#line 11902 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point3_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 282 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->z; 
#line 11934 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point3_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_serialize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 288 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     char buf[2048]; sprintf(buf, "%ld,%ld,%ld", THIS->x, THIS->y, THIS->z); RETVAL = buf; 
#line 11965 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Pointf_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "CLASS, _x= 0, _y= 0");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Pointf *	RETVAL;
	double	_x;
	double	_y;

	if (items < 2)
	    _x = 0;
	else {
	    _x = (double)SvNV(ST(1))
;
	}

	if (items < 3)
	    _y = 0;
	else {
	    _y = (double)SvNV(ST(2))
;
	}
#line 300 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      RETVAL = new Pointf( _x, _y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12015 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Pointf_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 317 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12062 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 330 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS; 
#line 12092 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 336 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = to_SV_pureperl(THIS); 
#line 12130 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 342 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = to_SV_pureperl(THIS); 
#line 12162 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 348 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->x; 
#line 12195 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 354 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->y; 
#line 12227 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_set_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_set_x)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::set_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 360 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     THIS->x = val; 
#line 12259 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_set_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_set_y)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::set_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 365 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     THIS->y = val; 
#line 12290 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Pointf *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 370 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12331 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Pointf *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 383 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12370 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center");
    {
	Pointf *	THIS;
	double	angle = (double)SvNV(ST(1))
;
	Pointf*	center;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(center) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(center) )) {
              center = (Pointf *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("center is not of type %s (got %s)", Slic3r::perl_class_name(center), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::rotate() -- center is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 396 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     THIS->rotate(angle, *center); 
#line 12415 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_negative); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_negative)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::negative() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 401 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->negative(); 
#line 12445 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_vector_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_vector_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Pointf *	THIS;
	Clone<Pointf>	RETVAL;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::vector_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::vector_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 407 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->vector_to(*point); 
#line 12497 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_serialize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 413 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     char buf[2048]; sprintf(buf, "%lf,%lf", THIS->x, THIS->y); RETVAL = buf; 
#line 12535 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Pointf3_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 4)
       croak_xs_usage(cv,  "CLASS, _x= 0, _y= 0, _z= 0");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Pointf3 *	RETVAL;
	double	_x;
	double	_y;
	double	_z;

	if (items < 2)
	    _x = 0;
	else {
	    _x = (double)SvNV(ST(1))
;
	}

	if (items < 3)
	    _y = 0;
	else {
	    _y = (double)SvNV(ST(2))
;
	}

	if (items < 4)
	    _z = 0;
	else {
	    _z = (double)SvNV(ST(3))
;
	}
#line 425 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      RETVAL = new Pointf3( _x, _y, _z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12593 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Pointf3_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 442 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12640 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 455 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS; 
#line 12670 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 461 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->x; 
#line 12709 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 467 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->y; 
#line 12741 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 473 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->z; 
#line 12773 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_set_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_set_x)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf3 *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::set_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 479 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     THIS->x = val; 
#line 12805 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_set_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_set_y)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf3 *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::set_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 484 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     THIS->y = val; 
#line 12836 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_set_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_set_z)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf3 *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::set_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 489 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     THIS->z = val; 
#line 12867 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	Pointf3 *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 494 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12910 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Pointf3 *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 507 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12949 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_distance_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_distance_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Pointf3 *	THIS;
	double	RETVAL;
	dXSTARG;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::distance_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::distance_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 520 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->distance_to(*point); 
#line 12994 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_negative); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_negative)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::negative() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 526 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->negative(); 
#line 13025 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_vector_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_vector_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Pointf3 *	THIS;
	Clone<Pointf3>	RETVAL;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::vector_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::vector_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 532 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     RETVAL = THIS->vector_to(*point); 
#line 13077 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_serialize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 538 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp"
     char buf[2048]; sprintf(buf, "%lf,%lf,%lf", THIS->x, THIS->y, THIS->z); RETVAL = buf; 
#line 13115 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Point.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include <vector>
#include "libslic3r/PlaceholderParser.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PlaceholderParser *	RETVAL;
#line 22 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
    try {
      RETVAL = new PlaceholderParser();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13159 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PlaceholderParser *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13206 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PlaceholderParser *	THIS;
	Clone<PlaceholderParser>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 52 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
     RETVAL = THIS; 
#line 13236 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<PlaceholderParser>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_update_timestamp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_update_timestamp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PlaceholderParser *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::update_timestamp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 58 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
    try {
      THIS->update_timestamp();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13281 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_apply_env_variables); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_apply_env_variables)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PlaceholderParser *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::apply_env_variables() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 71 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
    try {
      THIS->apply_env_variables();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13318 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_apply_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_apply_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, config");
    {
	PlaceholderParser *	THIS;
	DynamicPrintConfig*	config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::apply_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(config) )) {
              config = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("config is not of type %s (got %s)", Slic3r::perl_class_name(config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::apply_config() -- config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 84 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
     THIS->apply_config(*config); 
#line 13361 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, key, value");
    {
	PlaceholderParser *	THIS;
	std::string	key;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::set() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      key = std::string(c, len);
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(2), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(2), len);
      value = std::string(c, len);
    }
;
#line 89 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
    try {
      THIS->set( key, value );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13418 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_set_multiple); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_set_multiple)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, key, values");
    {
	PlaceholderParser *	THIS;
	std::string	key;
	std::vector< std::string >	values;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::set_multiple() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      key = std::string(c, len);
    }
;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(2));
	  const unsigned int alen = av_len(av)+1;
	  values = std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	    tmp = SvPV(*elem, len);
	      values[i] = std::string(tmp, len);
	    }
	    else
	      values[i] = std::string("");
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GCode::PlaceholderParser::set_multiple",
	             "values")
;
#line 102 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
    try {
      THIS->set( key, values );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13489 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_process); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_process)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, str");
    {
	PlaceholderParser *	THIS;
	std::string	RETVAL;
	std::string	str;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::process() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      str = std::string(c, len);
    }
;
#line 115 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp"
     RETVAL = THIS->process(str, 0); 
#line 13529 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PlaceholderParser.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/PerimeterGenerator.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_new)
{
    dVAR; dXSARGS;
    if (items != 10)
       croak_xs_usage(cv,  "CLASS, slices, layer_height, flow, region_config, object_config, print_config, loops, gap_fill, fill_surfaces");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PerimeterGenerator *	RETVAL;
	SurfaceCollection*	slices;
	double	layer_height = (double)SvNV(ST(2))
;
	Flow*	flow;
	StaticPrintConfig*	region_config;
	StaticPrintConfig*	object_config;
	StaticPrintConfig*	print_config;
	ExtrusionEntityCollection*	loops;
	ExtrusionEntityCollection*	gap_fill;
	SurfaceCollection*	fill_surfaces;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(slices) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(slices) )) {
              slices = (SurfaceCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("slices is not of type %s (got %s)", Slic3r::perl_class_name(slices), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
        if ( sv_isa(ST(3), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(3) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(3)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(4)) && (SvTYPE(SvRV(ST(4))) == SVt_PVMG) ) {
        if ( sv_isa(ST(4), Slic3r::perl_class_name(region_config) ) ||  sv_isa(ST(4), Slic3r::perl_class_name_ref(region_config) )) {
              region_config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(4) ));
        } else {
              croak("region_config is not of type %s (got %s)", Slic3r::perl_class_name(region_config), HvNAME(SvSTASH(SvRV(ST(4)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- region_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(5)) && (SvTYPE(SvRV(ST(5))) == SVt_PVMG) ) {
        if ( sv_isa(ST(5), Slic3r::perl_class_name(object_config) ) ||  sv_isa(ST(5), Slic3r::perl_class_name_ref(object_config) )) {
              object_config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(5) ));
        } else {
              croak("object_config is not of type %s (got %s)", Slic3r::perl_class_name(object_config), HvNAME(SvSTASH(SvRV(ST(5)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- object_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(6)) && (SvTYPE(SvRV(ST(6))) == SVt_PVMG) ) {
        if ( sv_isa(ST(6), Slic3r::perl_class_name(print_config) ) ||  sv_isa(ST(6), Slic3r::perl_class_name_ref(print_config) )) {
              print_config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(6) ));
        } else {
              croak("print_config is not of type %s (got %s)", Slic3r::perl_class_name(print_config), HvNAME(SvSTASH(SvRV(ST(6)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- print_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(7)) && (SvTYPE(SvRV(ST(7))) == SVt_PVMG) ) {
        if ( sv_isa(ST(7), Slic3r::perl_class_name(loops) ) ||  sv_isa(ST(7), Slic3r::perl_class_name_ref(loops) )) {
              loops = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(7) ));
        } else {
              croak("loops is not of type %s (got %s)", Slic3r::perl_class_name(loops), HvNAME(SvSTASH(SvRV(ST(7)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- loops is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(8)) && (SvTYPE(SvRV(ST(8))) == SVt_PVMG) ) {
        if ( sv_isa(ST(8), Slic3r::perl_class_name(gap_fill) ) ||  sv_isa(ST(8), Slic3r::perl_class_name_ref(gap_fill) )) {
              gap_fill = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(8) ));
        } else {
              croak("gap_fill is not of type %s (got %s)", Slic3r::perl_class_name(gap_fill), HvNAME(SvSTASH(SvRV(ST(8)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- gap_fill is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(9)) && (SvTYPE(SvRV(ST(9))) == SVt_PVMG) ) {
        if ( sv_isa(ST(9), Slic3r::perl_class_name(fill_surfaces) ) ||  sv_isa(ST(9), Slic3r::perl_class_name_ref(fill_surfaces) )) {
              fill_surfaces = (SurfaceCollection *)SvIV((SV*)SvRV( ST(9) ));
        } else {
              croak("fill_surfaces is not of type %s (got %s)", Slic3r::perl_class_name(fill_surfaces), HvNAME(SvSTASH(SvRV(ST(9)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- fill_surfaces is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
     RETVAL = new PerimeterGenerator(slices, layer_height, *flow,
            dynamic_cast<PrintRegionConfig*>(region_config),
            dynamic_cast<PrintObjectConfig*>(object_config),
            dynamic_cast<PrintConfig*>(print_config),
            loops, gap_fill, fill_surfaces); 
#line 13682 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PerimeterGenerator *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 34 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13729 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_lower_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_lower_slices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, lower_slices");
    {
	PerimeterGenerator *	THIS;
	ExPolygonCollection*	lower_slices;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_lower_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(lower_slices) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(lower_slices) )) {
              lower_slices = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("lower_slices is not of type %s (got %s)", Slic3r::perl_class_name(lower_slices), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_lower_slices() -- lower_slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 47 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
     THIS->lower_slices = lower_slices; 
#line 13772 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_layer_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_layer_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer_id");
    {
	PerimeterGenerator *	THIS;
	int	layer_id = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_layer_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 52 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
     THIS->layer_id = layer_id; 
#line 13803 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_perimeter_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_perimeter_flow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flow");
    {
	PerimeterGenerator *	THIS;
	Flow*	flow;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_perimeter_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_perimeter_flow() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
     THIS->perimeter_flow = *flow; 
#line 13846 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_ext_perimeter_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_ext_perimeter_flow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flow");
    {
	PerimeterGenerator *	THIS;
	Flow*	flow;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_ext_perimeter_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_ext_perimeter_flow() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
     THIS->ext_perimeter_flow = *flow; 
#line 13889 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_overhang_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_overhang_flow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flow");
    {
	PerimeterGenerator *	THIS;
	Flow*	flow;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_overhang_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_overhang_flow() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 67 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
     THIS->overhang_flow = *flow; 
#line 13932 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_solid_infill_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_solid_infill_flow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flow");
    {
	PerimeterGenerator *	THIS;
	Flow*	flow;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_solid_infill_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_solid_infill_flow() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 72 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
     THIS->solid_infill_flow = *flow; 
#line 13975 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PerimeterGenerator *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
     RETVAL = THIS->config; 
#line 14005 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_process); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_process)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PerimeterGenerator *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::process() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 83 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp"
    try {
      THIS->process();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14050 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/MotionPlanner.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/PerimeterGenerator.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/MotionPlanner.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__MotionPlanner_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__MotionPlanner_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, islands");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	MotionPlanner *	RETVAL;
	ExPolygons	islands;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        islands.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &islands[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::MotionPlanner::new",
	             "islands")
;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/MotionPlanner.xsp"
    try {
      RETVAL = new MotionPlanner( islands );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14102 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__MotionPlanner_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__MotionPlanner_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MotionPlanner *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (MotionPlanner *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/MotionPlanner.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14149 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__MotionPlanner_islands_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__MotionPlanner_islands_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MotionPlanner *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (MotionPlanner *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::islands_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/MotionPlanner.xsp"
    try {
      RETVAL = THIS->islands_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14188 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__MotionPlanner_shortest_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__MotionPlanner_shortest_path)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, from, to");
    {
	MotionPlanner *	THIS;
	Clone<Polyline>	RETVAL;
	Point*	from;
	Point*	to;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (MotionPlanner *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::shortest_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(from) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(from) )) {
              from = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("from is not of type %s (got %s)", Slic3r::perl_class_name(from), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::shortest_path() -- from is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(to) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(to) )) {
              to = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("to is not of type %s (got %s)", Slic3r::perl_class_name(to), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::shortest_path() -- to is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 65 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/MotionPlanner.xsp"
     RETVAL = THIS->shortest_path(*from, *to); 
#line 14247 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/MotionPlanner.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Model.hpp"
#include "libslic3r/PrintConfig.hpp"
#include "libslic3r/Slicing.hpp"
#include "libslic3r/Format/AMF.hpp"
#include "libslic3r/Format/OBJ.hpp"
#include "libslic3r/Format/PRUS.hpp"
#include "libslic3r/Format/STL.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Model_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Model *	RETVAL;
#line 27 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = new Model();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14298 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Model_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14345 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Model_read_from_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_read_from_file)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "CLASS, input_file, add_default_instances= true");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Model *	RETVAL;
	std::string	input_file;
	bool	add_default_instances;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      input_file = std::string(c, len);
    }
;

	if (items < 3)
	    add_default_instances = true;
	else {
	    add_default_instances = (bool)SvUV(ST(2))
;
	}
#line 60 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
            try {
                RETVAL = new Model(Model::read_from_file(input_file, add_default_instances));
            } catch (std::exception& e) {
                croak("Error while opening %s: %s\n", input_file.c_str(), e.what());
            }
#line 14387 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Model_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Clone<Model>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS; 
#line 14427 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Model>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__add_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__add_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Ref<ModelObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::_add_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 79 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->add_object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14473 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__add_object_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__add_object_clone)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, other, copy_volumes= true");
    {
	Model *	THIS;
	Ref<ModelObject>	RETVAL;
	ModelObject*	other;
	bool	copy_volumes;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::_add_object_clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (ModelObject *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::_add_object_clone() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    copy_volumes = true;
	else {
	    copy_volumes = (bool)SvUV(ST(2))
;
	}
#line 93 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->add_object(*other, copy_volumes); 
#line 14533 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_delete_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_delete_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Model *	THIS;
	size_t	idx = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::delete_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 99 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->delete_object( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14580 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_clear_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_clear_objects)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::clear_objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 112 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->clear_objects();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14617 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_objects_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_objects_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::objects_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 125 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->objects.size(); 
#line 14648 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_get_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_get_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Model *	THIS;
	Ref<ModelObject>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::get_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 131 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->objects.at(idx); 
#line 14681 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_get_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_get_material)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	Model *	THIS;
	Ref<ModelMaterial>	RETVAL;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::get_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 137 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
            RETVAL = THIS->get_material(material_id);
            if (RETVAL == NULL) {
                XSRETURN_UNDEF;
            }
#line 14732 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelMaterial>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_add_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_add_material)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	Model *	THIS;
	Ref<ModelMaterial>	RETVAL;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::add_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 146 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->add_material( material_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14788 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelMaterial>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_add_material_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_add_material_clone)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, material_id, other");
    {
	Model *	THIS;
	Ref<ModelMaterial>	RETVAL;
	t_model_material_id	material_id;
	ModelMaterial*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::add_material_clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(other) )) {
              other = (ModelMaterial *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::add_material_clone() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 160 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->add_material(material_id, *other); 
#line 14850 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelMaterial>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_has_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_has_material)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::has_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 166 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
            RETVAL = (THIS->get_material(material_id) != NULL);
#line 14899 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_delete_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_delete_material)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	Model *	THIS;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::delete_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 172 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->delete_material( material_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14947 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_clear_materials); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_clear_materials)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::clear_materials() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 185 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->clear_materials();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14984 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_material_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_material_names)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	std::vector<std::string>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::material_names() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 198 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
            for (ModelMaterialMap::iterator i = THIS->materials.begin();
                i != THIS->materials.end(); ++i)
            {
                RETVAL.push_back(i->first);
            }
#line 15018 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_material_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_material_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::material_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 208 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->materials.size(); 
#line 15065 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_add_default_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_add_default_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::add_default_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 214 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->add_default_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15105 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 228 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15144 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_center_instances_around_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_center_instances_around_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Model *	THIS;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::center_instances_around_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::center_instances_around_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 242 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->center_instances_around_point(*point); 
#line 15195 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	Model *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 247 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15238 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 260 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->mesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15276 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_objects)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	ModelObjectPtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 274 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->objects; 
#line 15314 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (ModelObjectPtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_arrange_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_arrange_objects)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, dist, bb= NULL");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	double	dist = (double)SvNV(ST(1))
;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::arrange_objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    bb = NULL;
	else {
    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
	if ( sv_isa(ST(2), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(bb) )) {
	      bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(2) ));
	} else {
	      croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(2)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Model::arrange_objects() -- bb is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 280 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->arrange_objects( dist, bb );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15387 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_duplicate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_duplicate)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, copies_num, dist, bb= NULL");
    {
	Model *	THIS;
	unsigned int	copies_num = (unsigned int)SvUV(ST(1))
;
	double	dist = (double)SvNV(ST(2))
;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::duplicate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    bb = NULL;
	else {
    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
	if ( sv_isa(ST(3), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(bb) )) {
	      bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(3) ));
	} else {
	      croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(3)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Model::duplicate() -- bb is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 294 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->duplicate( copies_num, dist, bb );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15447 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_duplicate_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_duplicate_objects)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, copies_num, dist, bb= NULL");
    {
	Model *	THIS;
	unsigned int	copies_num = (unsigned int)SvUV(ST(1))
;
	double	dist = (double)SvNV(ST(2))
;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::duplicate_objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    bb = NULL;
	else {
    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
	if ( sv_isa(ST(3), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(bb) )) {
	      bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(3) ));
	} else {
	      croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(3)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Model::duplicate_objects() -- bb is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 307 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->duplicate_objects( copies_num, dist, bb );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15506 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_duplicate_objects_grid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_duplicate_objects_grid)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, dist");
    {
	Model *	THIS;
	unsigned int	x = (unsigned int)SvUV(ST(1))
;
	unsigned int	y = (unsigned int)SvUV(ST(2))
;
	double	dist = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::duplicate_objects_grid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 320 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->duplicate_objects_grid( x, y, dist );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15549 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_looks_like_multipart_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_looks_like_multipart_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::looks_like_multipart_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 333 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->looks_like_multipart_object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15588 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_convert_multipart_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_convert_multipart_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::convert_multipart_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 347 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->convert_multipart_object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15626 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_print_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_print_info)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::print_info() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 360 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->print_info();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15663 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_store_stl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_store_stl)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, path, binary");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	char*	path = (char *)SvPV_nolen(ST(1))
;
	bool	binary = (bool)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::store_stl() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 373 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     TriangleMesh mesh = THIS->mesh(); RETVAL = Slic3r::store_stl(path, &mesh, binary); 
#line 15698 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_store_amf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_store_amf)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	char*	path = (char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::store_amf() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 379 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = Slic3r::store_amf(path, THIS); 
#line 15732 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_load_stl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_load_stl)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "CLASS, path, object_name");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	char*	path = (char *)SvPV_nolen(ST(1))
;
	char*	object_name = (char *)SvPV_nolen(ST(2))
;
	Model *	RETVAL;
#line 390 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
        RETVAL = new Model();
        if (! load_stl(path, RETVAL, object_name)) {
            delete RETVAL;
            RETVAL = NULL;
        }
#line 15759 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_load_obj); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_load_obj)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "CLASS, path, object_name");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	char*	path = (char *)SvPV_nolen(ST(1))
;
	char*	object_name = (char *)SvPV_nolen(ST(2))
;
	Model *	RETVAL;
#line 404 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
        RETVAL = new Model();
        if (! load_obj(path, RETVAL, object_name)) {
            delete RETVAL;
            RETVAL = NULL;
        }
#line 15793 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_load_amf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_load_amf)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, path");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	char*	path = (char *)SvPV_nolen(ST(1))
;
	Model *	RETVAL;
#line 417 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
        RETVAL = new Model();
        if (! load_amf(path, RETVAL)) {
            delete RETVAL;
            RETVAL = NULL;
        }
#line 15825 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_load_prus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_load_prus)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, path");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	char*	path = (char *)SvPV_nolen(ST(1))
;
	Model *	RETVAL;
#line 430 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
#ifdef SLIC3R_PRUS
        RETVAL = new Model();
        if (! load_prus(path, RETVAL)) {
            delete RETVAL;
            RETVAL = NULL;
        }
#else
        RETVAL = nullptr;
#endif
#line 15861 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Material_model); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_model)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelMaterial *	THIS;
	Ref<Model>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::model() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 450 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->get_model(); 
#line 15899 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Model>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Material_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelMaterial *	THIS;
	Ref<DynamicPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 456 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->config; 
#line 15937 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<DynamicPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Material_get_attribute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_get_attribute)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	ModelMaterial *	THIS;
	std::string	RETVAL;
	std::string	name;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::get_attribute() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      name = std::string(c, len);
    }
;
#line 462 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     if (THIS->attributes.find(name) != THIS->attributes.end()) RETVAL = THIS->attributes[name]; 
#line 15985 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Material_set_attribute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_set_attribute)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, name, value");
    {
	ModelMaterial *	THIS;
	std::string	name;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::set_attribute() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      name = std::string(c, len);
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(2), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(2), len);
      value = std::string(c, len);
    }
;
#line 468 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->attributes[name] = value; 
#line 16040 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Material_attributes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_attributes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelMaterial *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::attributes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 475 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
        HV* hv = newHV();
        for (t_model_material_attributes::const_iterator attr = THIS->attributes.begin(); attr != THIS->attributes.end(); ++attr) {
            (void)hv_store( hv, attr->first.c_str(), attr->first.length(), newSVpv(attr->second.c_str(), attr->second.length()), 0 );
        }
        RETVAL = (SV*)newRV_noinc((SV*)hv);
#line 16074 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_volumes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_volumes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	ModelVolumePtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::volumes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 490 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->volumes; 
#line 16106 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (ModelVolumePtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	ModelInstancePtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 496 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->instances; 
#line 16150 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (ModelInstancePtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_invalidate_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_invalidate_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::invalidate_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 502 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->invalidate_bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16201 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 515 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->mesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16239 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_raw_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_raw_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::raw_mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 529 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->raw_mesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16285 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_instance_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_instance_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	Clone<BoundingBoxf3>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::instance_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 543 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->instance_bounding_box(idx, true); 
#line 16325 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 549 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16371 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__add_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__add_volume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, mesh");
    {
	ModelObject *	THIS;
	Ref<ModelVolume>	RETVAL;
	TriangleMesh*	mesh;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(mesh) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(mesh) )) {
              mesh = (TriangleMesh *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("mesh is not of type %s (got %s)", Slic3r::perl_class_name(mesh), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_volume() -- mesh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 563 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->add_volume(*mesh); 
#line 16423 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelVolume>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__add_volume_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__add_volume_clone)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	ModelObject *	THIS;
	Ref<ModelVolume>	RETVAL;
	ModelVolume*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_volume_clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (ModelVolume *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_volume_clone() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 569 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->add_volume(*other); 
#line 16475 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelVolume>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_delete_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_delete_volume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	size_t	idx = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::delete_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 575 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->delete_volume( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16522 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_clear_volumes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_clear_volumes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::clear_volumes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 588 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->clear_volumes();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16559 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_volumes_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_volumes_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::volumes_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 601 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->volumes.size(); 
#line 16590 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_get_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_get_volume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	Ref<ModelVolume>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::get_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 607 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->volumes.at(idx); 
#line 16623 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelVolume>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_move_volume_up); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_move_volume_up)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::move_volume_up() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 613 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
            if (idx > 0 && idx < int(THIS->volumes.size())) {
                std::swap(THIS->volumes[idx-1], THIS->volumes[idx]);
                RETVAL = true;
            } else
                RETVAL = false;
#line 16668 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_move_volume_down); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_move_volume_down)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::move_volume_down() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 623 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
            if (idx >= 0 && idx + 1 < int(THIS->volumes.size())) {
                std::swap(THIS->volumes[idx+1], THIS->volumes[idx]);
                RETVAL = true;
            } else
                RETVAL = false;
#line 16706 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__add_instance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__add_instance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<ModelInstance>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_instance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 633 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->add_instance();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16745 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelInstance>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__add_instance_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__add_instance_clone)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	ModelObject *	THIS;
	Ref<ModelInstance>	RETVAL;
	ModelInstance*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_instance_clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (ModelInstance *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_instance_clone() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 647 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->add_instance(*other); 
#line 16797 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelInstance>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_delete_last_instance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_delete_last_instance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::delete_last_instance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 653 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->delete_last_instance();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16842 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_clear_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_clear_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::clear_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 666 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->clear_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16879 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_instances_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_instances_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::instances_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 679 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->instances.size(); 
#line 16910 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::name() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 685 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->name; 
#line 16941 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_name)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	ModelObject *	THIS;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_name() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      value = std::string(c, len);
    }
;
#line 691 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->name = value; 
#line 16986 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_input_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_input_file)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::input_file() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 696 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->input_file; 
#line 17016 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_input_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_input_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	ModelObject *	THIS;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_input_file() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      value = std::string(c, len);
    }
;
#line 702 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->input_file = value; 
#line 17061 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<DynamicPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 707 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->config; 
#line 17091 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<DynamicPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_model); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_model)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<Model>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::model() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 713 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->get_model(); 
#line 17129 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Model>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_layer_height_ranges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_layer_height_ranges)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	t_layer_height_ranges	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::layer_height_ranges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 719 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->layer_height_ranges; 
#line 17167 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
    // map is sorted, so we can just copy it in order
    int i = 0;
    for (t_layer_height_ranges::iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    const coordf_t range_values[] = {
		    it->first.first,    // key's first = minz
		    it->first.second,   // key's second = maxz
		    it->second,	 // value = height
		};
	    AV *rangeAV = newAV();
	    av_extend(rangeAV, 2);
	    for (int j = 0; j < 3; ++j) {
		av_store(rangeAV, j, newSVnv(range_values[j]));
	    }
	    av_store(av, i++, (SV*)newRV_noinc((SV*)rangeAV));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_layer_height_ranges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_layer_height_ranges)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, ranges");
    {
	ModelObject *	THIS;
	t_layer_height_ranges	ranges;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_layer_height_ranges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
        if (!SvROK(ST(1)) || SvTYPE(SvRV(ST(1))) != SVt_PVAV) {
            Perl_croak(aTHX_ "%s: %s is not an array reference",
                     "Slic3r::Model::Object::set_layer_height_ranges",
                     "ranges");
        }
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        t_layer_height_ranges tmp_ranges;
        for (unsigned int i = 0; i < len; i++) {
            SV* elem = *av_fetch(av, i, 0);
            if (!SvROK(elem) || SvTYPE(SvRV(elem)) != SVt_PVAV) {
                Perl_croak(
                    aTHX_ "%s: %s contains something that is not an array reference",
                        "Slic3r::Model::Object::set_layer_height_ranges",
                        "ranges");
            }
            AV* elemAV = (AV*)SvRV(elem);
            if (av_len(elemAV) + 1 != 3) {
                Perl_croak(
                    aTHX_ "%s: %s contains an array that isn't 3 elements long",
                        "Slic3r::Model::Object::set_layer_height_ranges",
                        "ranges");
            }
            coordf_t vals[3];
            for (unsigned int j = 0; j < 3; ++j) {
                SV *elem_elem = *av_fetch(elemAV, j, 0);
                if (!looks_like_number(elem_elem)) {
                    Perl_croak(
                        aTHX_ "%s: layer ranges and heights must be numbers",
                            "Slic3r::Model::Object::set_layer_height_ranges");
                }
                vals[j] = SvNV(elem_elem);
            }
            tmp_ranges[t_layer_height_range(vals[0], vals[1])] = vals[2];
        }
        ranges = tmp_ranges;
    }
;
#line 725 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->layer_height_ranges = ranges; 
#line 17262 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_layer_height_profile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_layer_height_profile)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::layer_height_profile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 730 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->layer_height_profile_valid ? THIS->layer_height_profile : std::vector<double>(); 
#line 17292 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_layer_height_profile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_layer_height_profile)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, profile");
    {
	ModelObject *	THIS;
	std::vector< double >	profile;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_layer_height_profile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  profile = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      profile[i] = SvNV(*elem);
	    else
	      profile[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Model::Object::set_layer_height_profile",
	             "profile")
;
#line 736 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->layer_height_profile = profile; THIS->layer_height_profile_valid = true; 
#line 17355 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_origin_translation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_origin_translation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::origin_translation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 741 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->origin_translation; 
#line 17385 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_origin_translation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_origin_translation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ModelObject *	THIS;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_origin_translation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_origin_translation() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 747 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->origin_translation = *point; 
#line 17436 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_needed_repair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_needed_repair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::needed_repair() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 752 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->needed_repair();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17475 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_materials_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_materials_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::materials_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 766 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->materials_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17515 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_facets_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_facets_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::facets_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 780 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->facets_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17555 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_center_around_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_center_around_origin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::center_around_origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 794 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->center_around_origin();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17593 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	ModelObject *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 807 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17636 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_scale_xyz); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_scale_xyz)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, versor");
    {
	ModelObject *	THIS;
	Pointf3*	versor;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::scale_xyz() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(versor) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(versor) )) {
              versor = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("versor is not of type %s (got %s)", Slic3r::perl_class_name(versor), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::scale_xyz() -- versor is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 820 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->scale(*versor); 
#line 17679 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, axis");
    {
	ModelObject *	THIS;
	float	angle = (float)SvNV(ST(1))
;
	Axis	axis = (Axis)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 825 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
    axis = (Axis)SvUV(ST(2));
  ;
      THIS->rotate( angle, axis );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17722 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_mirror); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_mirror)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, axis");
    {
	ModelObject *	THIS;
	Axis	axis = (Axis)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::mirror() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 840 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
    axis = (Axis)SvUV(ST(1));
  ;
      THIS->mirror( axis );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17763 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_cut); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_cut)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	ModelObject *	THIS;
	Model *	RETVAL;
	double	z = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::cut() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 855 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
            RETVAL = new Model();
            THIS->cut(z, RETVAL);
#line 17796 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_split_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_split_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	ModelObjectPtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::split_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 862 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
            RETVAL = new ModelObjectPtrs();  // leak?
            THIS->split(RETVAL);
#line 17835 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (ModelObjectPtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_print_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_print_info)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::print_info() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 869 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->print_info();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17886 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Ref<ModelObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 885 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->get_object(); 
#line 17916 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::name() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 891 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->name; 
#line 17954 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_name)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	ModelVolume *	THIS;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_name() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      value = std::string(c, len);
    }
;
#line 897 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->name = value; 
#line 17999 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_material_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_material_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	t_model_material_id	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::material_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 902 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->material_id();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18037 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_material_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_material_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	ModelVolume *	THIS;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_material_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 916 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->material_id(material_id); 
#line 18082 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_material)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Ref<ModelMaterial>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 921 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->material();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18120 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelMaterial>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Ref<DynamicPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 935 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->config; 
#line 18158 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<DynamicPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Ref<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 941 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->mesh; 
#line 18196 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_modifier); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_modifier)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::modifier() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 947 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->modifier; 
#line 18235 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_modifier); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_modifier)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, modifier");
    {
	ModelVolume *	THIS;
	bool	modifier = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_modifier() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 953 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->modifier = modifier; 
#line 18267 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_split); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_split)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::split() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 958 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->split();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18306 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_assign_unique_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_assign_unique_material)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	ModelMaterial *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::assign_unique_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 972 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      RETVAL = THIS->assign_unique_material();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18345 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	Ref<ModelObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 989 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->get_object(); 
#line 18383 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_rotation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_rotation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::rotation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 995 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->rotation; 
#line 18422 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_scaling_factor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_scaling_factor)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::scaling_factor() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1001 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = THIS->scaling_factor; 
#line 18454 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_offset)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	Ref<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1007 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     RETVAL = &THIS->offset; 
#line 18485 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_rotation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_rotation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	ModelInstance *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_rotation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1013 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->rotation = val; 
#line 18524 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_scaling_factor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_scaling_factor)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	ModelInstance *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_scaling_factor() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1018 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->scaling_factor = val; 
#line 18555 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_offset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, offset");
    {
	ModelInstance *	THIS;
	Pointf*	offset;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(offset) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(offset) )) {
              offset = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("offset is not of type %s (got %s)", Slic3r::perl_class_name(offset), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_offset() -- offset is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1023 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
     THIS->offset = *offset; 
#line 18598 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_transform_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_transform_mesh)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, mesh, dont_translate= false");
    {
	ModelInstance *	THIS;
	TriangleMesh*	mesh;
	bool	dont_translate;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::transform_mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(mesh) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(mesh) )) {
              mesh = (TriangleMesh *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("mesh is not of type %s (got %s)", Slic3r::perl_class_name(mesh), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::transform_mesh() -- mesh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    dont_translate = false;
	else {
	    dont_translate = (bool)SvUV(ST(2))
;
	}
#line 1028 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->transform_mesh( mesh, dont_translate );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18657 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_transform_polygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_transform_polygon)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polygon");
    {
	ModelInstance *	THIS;
	Polygon*	polygon;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::transform_polygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polygon) )) {
              polygon = (Polygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polygon is not of type %s (got %s)", Slic3r::perl_class_name(polygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::transform_polygon() -- polygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1041 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp"
    try {
      THIS->transform_polygon( polygon );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18708 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Model.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Line.hpp"
#include "libslic3r/Polyline.hpp"

XS_EUPXS(XS_Slic3r__Line_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 19 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18755 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Line>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 32 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = THIS; 
#line 18785 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Line>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = to_AV(THIS); 
#line 18823 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = to_SV_pureperl(THIS); 
#line 18855 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_a); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_a)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Ref<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::a() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 50 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL=&THIS->a; 
#line 18887 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_b); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_b)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Ref<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::b() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL=&THIS->b; 
#line 18925 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18970 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Line *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 75 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19009 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Line *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 88 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19050 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 101 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19089 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_atan2_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_atan2_)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::atan2_() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 115 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->atan2_();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19129 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_orientation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_orientation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::orientation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 129 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->orientation();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19169 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_direction); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_direction)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::direction() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 143 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->direction();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19209 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_parallel_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_parallel_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	Line *	THIS;
	bool	RETVAL;
	dXSTARG;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::parallel_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 157 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->parallel_to( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19251 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_parallel_to_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_parallel_to_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Line *	THIS;
	bool	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::parallel_to_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::parallel_to_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 171 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = THIS->parallel_to(*line); 
#line 19297 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_midpoint); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_midpoint)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::midpoint() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 177 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->midpoint();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19336 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_point_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_point_at)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::point_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 191 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->point_at( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19384 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_intersection_infinite); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_intersection_infinite)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;
	Line*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::intersection_infinite() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::intersection_infinite() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 205 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
            Point p;
            bool res = THIS->intersection_infinite(*other, &p);
            if (!res) CONFESS("Intersection failed");
            RETVAL = p;
#line 19439 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_as_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_as_polyline)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::as_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 214 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = Polyline(*THIS); 
#line 19477 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_normal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_normal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::normal() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 220 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->normal();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19523 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_vector); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_vector)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::vector() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 234 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->vector();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19569 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_ccw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_ccw)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::ccw() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::ccw() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 248 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = THIS->ccw(*point); 
#line 19622 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Line *	RETVAL;
#line 256 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
        RETVAL = new Line ();
        // ST(0) is class name, ST(1) and ST(2) are endpoints
        from_SV_check(ST(1), &RETVAL->a);
        from_SV_check(ST(2), &RETVAL->b);
#line 19644 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	Line *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 268 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 19687 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_coincides_with); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_coincides_with)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line_sv");
    {
	SV*	line_sv = ST(1)
;
	Line *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::coincides_with() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 276 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
        Line line;
        from_SV_check(line_sv, &line);
        RETVAL = THIS->coincides_with(line);
#line 19722 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Linef3_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_new)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "CLASS, a, b");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Linef3 *	RETVAL;
	Pointf3*	a;
	Pointf3*	b;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(a) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(a) )) {
              a = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("a is not of type %s (got %s)", Slic3r::perl_class_name(a), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::new() -- a is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(b) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(b) )) {
              b = (Pointf3 *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("b is not of type %s (got %s)", Slic3r::perl_class_name(b), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::new() -- b is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 293 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = new Linef3(*a, *b); 
#line 19771 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Linef3_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Linef3 *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 302 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19818 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Linef3_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Linef3 *	THIS;
	Clone<Linef3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 315 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = THIS; 
#line 19848 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Linef3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Linef3_a); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_a)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Linef3 *	THIS;
	Ref<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::a() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 321 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = &THIS->a; 
#line 19886 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Linef3_b); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_b)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Linef3 *	THIS;
	Ref<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::b() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 327 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
     RETVAL = &THIS->b; 
#line 19924 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Linef3_intersect_plane); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_intersect_plane)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	Linef3 *	THIS;
	Clone<Pointf3>	RETVAL;
	double	z = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::intersect_plane() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 333 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      RETVAL = THIS->intersect_plane( z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19972 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Linef3_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Linef3 *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 347 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20019 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Line.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Layer.hpp"

XS_EUPXS(XS_Slic3r__Layer__Region_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 19 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->layer();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20066 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_region)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<PrintRegion>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 33 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->region();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20112 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<SurfaceCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 47 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->slices; 
#line 20150 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SurfaceCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_thin_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_thin_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::thin_fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 53 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->thin_fills; 
#line 20188 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_fill_surfaces); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_fill_surfaces)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<SurfaceCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::fill_surfaces() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 59 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->fill_surfaces; 
#line 20226 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SurfaceCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_perimeter_surfaces); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_perimeter_surfaces)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<SurfaceCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::perimeter_surfaces() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 65 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->perimeter_surfaces; 
#line 20264 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SurfaceCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_bridged); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_bridged)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::bridged() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 71 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->bridged; 
#line 20302 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_unsupported_bridge_edges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_unsupported_bridge_edges)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<PolylineCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::unsupported_bridge_edges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->unsupported_bridge_edges; 
#line 20346 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PolylineCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_perimeters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 83 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->perimeters; 
#line 20384 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 89 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->fills; 
#line 20422 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_flow)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "THIS, role, bridge= false, width= -1");
    {
	LayerRegion *	THIS;
	Clone<Flow>	RETVAL;
	FlowRole	role = (FlowRole)SvUV(ST(1))
;
	bool	bridge;
	double	width;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    bridge = false;
	else {
	    bridge = (bool)SvUV(ST(2))
;
	}

	if (items < 4)
	    width = -1;
	else {
	    width = (double)SvNV(ST(3))
;
	}
#line 95 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->flow(role, bridge, width); 
#line 20478 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_prepare_fill_surfaces); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_prepare_fill_surfaces)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::prepare_fill_surfaces() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 101 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->prepare_fill_surfaces();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20523 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Region_make_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_make_perimeters)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, slices, fill_surfaces");
    {
	LayerRegion *	THIS;
	SurfaceCollection*	slices;
	SurfaceCollection*	fill_surfaces;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::make_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(slices) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(slices) )) {
              slices = (SurfaceCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("slices is not of type %s (got %s)", Slic3r::perl_class_name(slices), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::make_perimeters() -- slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(fill_surfaces) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(fill_surfaces) )) {
              fill_surfaces = (SurfaceCollection *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("fill_surfaces is not of type %s (got %s)", Slic3r::perl_class_name(fill_surfaces), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::make_perimeters() -- fill_surfaces is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 114 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     THIS->make_perimeters(*slices, fill_surfaces); 
#line 20580 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Region_infill_area_threshold); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_infill_area_threshold)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::infill_area_threshold() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 119 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->infill_area_threshold();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20619 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_export_region_slices_to_svg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_export_region_slices_to_svg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	LayerRegion *	THIS;
	const char*	path = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::export_region_slices_to_svg() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 133 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_slices_to_svg( path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20659 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Region_export_region_fill_surfaces_to_svg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_export_region_fill_surfaces_to_svg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	LayerRegion *	THIS;
	const char*	path = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::export_region_fill_surfaces_to_svg() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 146 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_fill_surfaces_to_svg( path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20698 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Region_export_region_slices_to_svg_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_export_region_slices_to_svg_debug)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	LayerRegion *	THIS;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::export_region_slices_to_svg_debug() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 159 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_slices_to_svg_debug( name );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20737 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Region_export_region_fill_surfaces_to_svg_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_export_region_fill_surfaces_to_svg_debug)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	LayerRegion *	THIS;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::export_region_fill_surfaces_to_svg_debug() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 172 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_fill_surfaces_to_svg_debug( name );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20776 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_as_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_as_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::as_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 189 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS; 
#line 20806 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 195 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->id();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20853 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_set_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_set_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, id");
    {
	Layer *	THIS;
	int	id = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 209 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->set_id( id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20893 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<PrintObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 222 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20931 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 236 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->upper_layer; 
#line 20969 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 242 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->lower_layer; 
#line 21007 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_slicing_errors); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_slicing_errors)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::slicing_errors() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 248 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->slicing_errors; 
#line 21046 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_slice_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_slice_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::slice_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 254 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->slice_z; 
#line 21078 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_print_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_print_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::print_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 260 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->print_z; 
#line 21110 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 266 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->height; 
#line 21142 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_set_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_set_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	Layer *	THIS;
	Layer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (Layer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_upper_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 272 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     THIS->upper_layer = layer; 
#line 21186 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_set_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_set_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	Layer *	THIS;
	Layer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (Layer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_lower_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 277 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     THIS->lower_layer = layer; 
#line 21229 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_has_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_has_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::has_upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 282 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = (THIS->upper_layer != NULL); 
#line 21260 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_has_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_has_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::has_lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 288 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = (THIS->lower_layer != NULL); 
#line 21292 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_region_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_region_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::region_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 294 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->region_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21332 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_get_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_get_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Layer *	THIS;
	Ref<LayerRegion>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::get_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 308 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->get_region( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21373 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_add_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_add_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, print_region");
    {
	Layer *	THIS;
	Ref<LayerRegion>	RETVAL;
	PrintRegion*	print_region;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::add_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print_region) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print_region) )) {
              print_region = (PrintRegion *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print_region is not of type %s (got %s)", Slic3r::perl_class_name(print_region), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::add_region() -- print_region is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 322 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->add_region( print_region );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21433 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<ExPolygonCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 336 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->slices; 
#line 21471 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExPolygonCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_ptr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_ptr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::ptr() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 342 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = (int)(intptr_t)THIS; 
#line 21510 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_as_support_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_as_support_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<SupportLayer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::as_support_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 348 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = dynamic_cast<SupportLayer*>(THIS); 
#line 21541 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_make_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_make_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::make_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 354 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->make_slices();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21586 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_merge_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_merge_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::merge_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 367 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->merge_slices();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21623 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_make_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_make_perimeters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::make_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 380 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->make_perimeters();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21660 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_make_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_make_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::make_fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 393 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->make_fills();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21697 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_export_region_slices_to_svg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_export_region_slices_to_svg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	Layer *	THIS;
	const char*	path = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::export_region_slices_to_svg() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 406 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_slices_to_svg( path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21736 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_export_region_fill_surfaces_to_svg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_export_region_fill_surfaces_to_svg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	Layer *	THIS;
	const char*	path = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::export_region_fill_surfaces_to_svg() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 419 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_fill_surfaces_to_svg( path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21775 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_export_region_slices_to_svg_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_export_region_slices_to_svg_debug)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	Layer *	THIS;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::export_region_slices_to_svg_debug() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 432 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_slices_to_svg_debug( name );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21814 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_export_region_fill_surfaces_to_svg_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_export_region_fill_surfaces_to_svg_debug)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	Layer *	THIS;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::export_region_fill_surfaces_to_svg_debug() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 445 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_fill_surfaces_to_svg_debug( name );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21853 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_as_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_as_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::as_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 462 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS; 
#line 21883 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_support_islands); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_support_islands)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<ExPolygonCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::support_islands() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 468 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->support_islands; 
#line 21921 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExPolygonCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_support_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_support_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::support_fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 474 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->support_fills; 
#line 21959 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 482 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->id();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22006 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_set_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_set_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, id");
    {
	SupportLayer *	THIS;
	int	id = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 496 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->set_id( id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22046 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<PrintObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 509 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22084 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<SupportLayer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 523 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = (SupportLayer*)THIS->upper_layer; 
#line 22122 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<SupportLayer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 529 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = (SupportLayer*)THIS->lower_layer; 
#line 22160 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_slicing_errors); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_slicing_errors)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::slicing_errors() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 535 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->slicing_errors; 
#line 22199 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_slice_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_slice_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::slice_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 541 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->slice_z; 
#line 22231 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_print_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_print_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::print_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 547 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->print_z; 
#line 22263 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 553 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = THIS->height; 
#line 22295 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_set_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_set_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	SupportLayer *	THIS;
	SupportLayer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (SupportLayer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_upper_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 559 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     THIS->upper_layer = layer; 
#line 22339 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_set_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_set_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	SupportLayer *	THIS;
	SupportLayer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (SupportLayer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_lower_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 564 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     THIS->lower_layer = layer; 
#line 22382 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_has_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_has_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::has_upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 569 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = (THIS->upper_layer != NULL); 
#line 22413 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_has_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_has_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::has_lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 575 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = (THIS->lower_layer != NULL); 
#line 22445 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_region_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_region_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::region_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 581 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->region_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22485 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_get_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_get_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	SupportLayer *	THIS;
	Ref<LayerRegion>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::get_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 595 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->get_region( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22526 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_add_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_add_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, print_region");
    {
	SupportLayer *	THIS;
	Ref<LayerRegion>	RETVAL;
	PrintRegion*	print_region;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::add_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print_region) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print_region) )) {
              print_region = (PrintRegion *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print_region is not of type %s (got %s)", Slic3r::perl_class_name(print_region), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::add_region() -- print_region is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 609 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      RETVAL = THIS->add_region( print_region );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22586 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<ExPolygonCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 623 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
     RETVAL = &THIS->slices; 
#line 22624 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExPolygonCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_export_region_slices_to_svg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_export_region_slices_to_svg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	SupportLayer *	THIS;
	const char*	path = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::export_region_slices_to_svg() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 629 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_slices_to_svg( path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22671 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_export_region_fill_surfaces_to_svg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_export_region_fill_surfaces_to_svg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	SupportLayer *	THIS;
	const char*	path = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::export_region_fill_surfaces_to_svg() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 642 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_fill_surfaces_to_svg( path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22710 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_export_region_slices_to_svg_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_export_region_slices_to_svg_debug)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	SupportLayer *	THIS;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::export_region_slices_to_svg_debug() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 655 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_slices_to_svg_debug( name );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22749 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_export_region_fill_surfaces_to_svg_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_export_region_fill_surfaces_to_svg_debug)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	SupportLayer *	THIS;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::export_region_fill_surfaces_to_svg_debug() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 668 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp"
    try {
      THIS->export_region_fill_surfaces_to_svg_debug( name );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22788 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Layer.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "slic3r/GUI/GLShader.hpp"
#include "slic3r/GUI/3DScene.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GLShader *	RETVAL;
#line 25 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = new GLShader();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22826 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLShader *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 42 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22873 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_load)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, fragment_shader, vertex_shader");
    {
	GLShader *	THIS;
	bool	RETVAL;
	dXSTARG;
	const char*	fragment_shader = (const char *)SvPV_nolen(ST(1))
;
	const char*	vertex_shader = (const char *)SvPV_nolen(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::load() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 55 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->load( fragment_shader, vertex_shader );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22916 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_release); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_release)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLShader *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::release() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 69 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->release();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22954 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_get_attrib_location); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_get_attrib_location)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	GLShader *	THIS;
	int	RETVAL;
	dXSTARG;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::get_attrib_location() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->get_attrib_location( name );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22995 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_get_uniform_location); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_get_uniform_location)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	GLShader *	THIS;
	int	RETVAL;
	dXSTARG;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::get_uniform_location() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 96 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->get_uniform_location( name );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23037 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_set_uniform); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_set_uniform)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, name, value");
    {
	GLShader *	THIS;
	bool	RETVAL;
	dXSTARG;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;
	float	value = (float)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::set_uniform() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 110 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->set_uniform( name, value );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23081 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_enable)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLShader *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::enable() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 124 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->enable();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23119 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_disable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_disable)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLShader *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::disable() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 137 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->disable();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23156 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_last_error); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLShader_last_error)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLShader *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLShader *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLShader::last_error() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 150 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL = THIS->last_error; 
#line 23186 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GLVolume *	RETVAL;
#line 162 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = new GLVolume();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23220 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 179 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23267 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_color); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_color)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::color() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 192 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL.reserve(4); RETVAL.push_back(THIS->color[0]); RETVAL.push_back(THIS->color[1]); RETVAL.push_back(THIS->color[2]); RETVAL.push_back(THIS->color[3]); 
#line 23297 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_select_group_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_select_group_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::select_group_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 198 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL = THIS->select_group_id; 
#line 23342 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_drag_group_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_drag_group_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::drag_group_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 204 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL = THIS->drag_group_id; 
#line 23374 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_selected); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_selected)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::selected() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 210 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL = THIS->selected; 
#line 23406 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_set_selected); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_set_selected)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, i");
    {
	GLVolume *	THIS;
	int	i = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::set_selected() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 216 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     THIS->selected = i; 
#line 23438 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_hover); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_hover)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::hover() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 221 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL = THIS->hover; 
#line 23469 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_set_hover); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_set_hover)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, i");
    {
	GLVolume *	THIS;
	int	i = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::set_hover() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 227 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     THIS->hover = i; 
#line 23501 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_object_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_object_idx)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::object_idx() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 232 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->object_idx();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23540 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_volume_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_volume_idx)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::volume_idx() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 246 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->volume_idx();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23580 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_instance_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_instance_idx)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::instance_idx() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 260 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->instance_idx();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23620 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_origin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 274 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL = THIS->origin; 
#line 23651 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	GLVolume *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 280 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     THIS->origin.translate(x, y, z); 
#line 23694 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 285 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL = THIS->bounding_box; 
#line 23724 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_transformed_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_transformed_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::transformed_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 291 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->transformed_bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23770 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::empty() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 305 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->empty();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23817 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_indexed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_indexed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::indexed() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 319 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->indexed();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23857 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_render); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_render)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::render() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 333 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->render();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23895 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_has_layer_height_texture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_has_layer_height_texture)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::has_layer_height_texture() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 346 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->has_layer_height_texture();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23934 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 360 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->layer_height_texture_width();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23974 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 374 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->layer_height_texture_height();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24014 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_cells); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_cells)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_cells() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 388 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->layer_height_texture_cells();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24054 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_data_ptr_level0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_data_ptr_level0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	void *	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_data_ptr_level0() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 402 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->layer_height_texture_data_ptr_level0();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24094 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_data_ptr_level1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_data_ptr_level1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	void *	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_data_ptr_level1() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 416 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->layer_height_texture_data_ptr_level1();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24134 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_z_to_row_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_z_to_row_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolume *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_z_to_row_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 430 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->layer_height_texture_z_to_row_id();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24174 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_generate_layer_height_texture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume_generate_layer_height_texture)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, print_object, force");
    {
	GLVolume *	THIS;
	PrintObject*	print_object;
	bool	force = (bool)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::generate_layer_height_texture() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print_object) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print_object) )) {
              print_object = (PrintObject *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print_object is not of type %s (got %s)", Slic3r::perl_class_name(print_object), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::generate_layer_height_texture() -- print_object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 444 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->generate_layer_height_texture( print_object, force );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24228 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GLVolumeCollection *	RETVAL;
#line 463 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = new GLVolumeCollection();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24256 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolumeCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 480 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24303 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_load_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_load_object)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "THIS, object, obj_idx, instance_idxs, color_by, select_by, drag_by, use_VBOs");
    {
	GLVolumeCollection *	THIS;
	std::vector<int>	RETVAL;
	ModelObject*	object;
	int	obj_idx = (int)SvIV(ST(2))
;
	std::vector< int >	instance_idxs;
	std::string	color_by;
	std::string	select_by;
	std::string	drag_by;
	bool	use_VBOs = (bool)SvUV(ST(7))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::load_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(object) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(object) )) {
              object = (ModelObject *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("object is not of type %s (got %s)", Slic3r::perl_class_name(object), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::load_object() -- object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(3)) && SvTYPE(SvRV(ST(3)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(3));
	  const unsigned int len = av_len(av)+1;
	  instance_idxs = std::vector<int>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      instance_idxs[i] = SvIV(*elem);
	    else
	      instance_idxs[i] = 0;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GUI::_3DScene::GLVolume::Collection::load_object",
	             "instance_idxs")
;

    {
      size_t len;
      // const char * c = SvPV(ST(4), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(4), len);
      color_by = std::string(c, len);
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(5), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(5), len);
      select_by = std::string(c, len);
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(6), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(6), len);
      drag_by = std::string(c, len);
    }
;
#line 493 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->load_object( object, obj_idx, instance_idxs, color_by, select_by, drag_by, use_VBOs );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24409 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_load_wipe_tower_preview); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_load_wipe_tower_preview)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "THIS, obj_idx, pos_x, pos_y, width, depth, height, use_VBOs");
    {
	GLVolumeCollection *	THIS;
	int	RETVAL;
	dXSTARG;
	int	obj_idx = (int)SvIV(ST(1))
;
	float	pos_x = (float)SvNV(ST(2))
;
	float	pos_y = (float)SvNV(ST(3))
;
	float	width = (float)SvNV(ST(4))
;
	float	depth = (float)SvNV(ST(5))
;
	float	height = (float)SvNV(ST(6))
;
	bool	use_VBOs = (bool)SvUV(ST(7))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::load_wipe_tower_preview() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 507 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      RETVAL = THIS->load_wipe_tower_preview( obj_idx, pos_x, pos_y, width, depth, height, use_VBOs );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24476 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_erase); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_erase)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolumeCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::erase() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 521 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     THIS->clear(); 
#line 24506 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolumeCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 526 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
     RETVAL = THIS->volumes.size(); 
#line 24537 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_set_range); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_set_range)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, low, high");
    {
	GLVolumeCollection *	THIS;
	double	low = (double)SvNV(ST(1))
;
	double	high = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::set_range() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 532 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->set_range( low, high );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24579 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_render_VBOs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_render_VBOs)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolumeCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::render_VBOs() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 545 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->render_VBOs();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24616 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_render_legacy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_render_legacy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolumeCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::render_legacy() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 558 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->render_legacy();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24653 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_finalize_geometry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_finalize_geometry)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, use_VBOs");
    {
	GLVolumeCollection *	THIS;
	bool	use_VBOs = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::finalize_geometry() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 571 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->finalize_geometry( use_VBOs );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24692 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_release_geometry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_release_geometry)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolumeCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::release_geometry() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 584 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
    try {
      THIS->release_geometry();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24729 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_move_volume_up); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_move_volume_up)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	GLVolumeCollection *	THIS;
	bool	RETVAL;
	dXSTARG;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::move_volume_up() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 597 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
            if (idx > 0 && idx < int(THIS->volumes.size())) {
                std::swap(THIS->volumes[idx-1], THIS->volumes[idx]);
                std::swap(THIS->volumes[idx-1]->composite_id,    THIS->volumes[idx]->composite_id);
                std::swap(THIS->volumes[idx-1]->select_group_id, THIS->volumes[idx]->select_group_id);
                std::swap(THIS->volumes[idx-1]->drag_group_id,   THIS->volumes[idx]->drag_group_id);
                RETVAL = true;
            } else
                RETVAL = false;
#line 24769 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_move_volume_down); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_move_volume_down)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	GLVolumeCollection *	THIS;
	bool	RETVAL;
	dXSTARG;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::move_volume_down() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 610 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
            if (idx >= 0 && idx + 1 < int(THIS->volumes.size())) {
                std::swap(THIS->volumes[idx+1], THIS->volumes[idx]);
                std::swap(THIS->volumes[idx+1]->composite_id,    THIS->volumes[idx]->composite_id);
                std::swap(THIS->volumes[idx+1]->select_group_id, THIS->volumes[idx]->select_group_id);
                std::swap(THIS->volumes[idx+1]->drag_group_id,   THIS->volumes[idx]->drag_group_id);
                RETVAL = true;
            } else
                RETVAL = false;
#line 24810 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVolume__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVolumeCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVolume::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 625 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
        AV* av = newAV();
        av_fill(av, THIS->volumes.size()-1);
        int i = 0;
        for (GLVolume *v : THIS->volumes) {
            av_store(av, i++, perl_to_SV_ref(*v));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 24847 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__glew_init); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__glew_init)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 646 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
        _3DScene::_glew_init();
#line 24864 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__load_print_toolpaths); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__load_print_toolpaths)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "print, volumes, tool_colors, use_VBOs");
    {
	Print *	print;
	GLVolumeCollection *	volumes;
	std::vector<std::string>	tool_colors;
	int	use_VBOs = (int)SvIV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(print) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(print) )) {
              print = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("print is not of type %s (got %s)", Slic3r::perl_class_name(print), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_load_print_toolpaths() -- print is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(volumes) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(volumes) )) {
              volumes = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("volumes is not of type %s (got %s)", Slic3r::perl_class_name(volumes), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_load_print_toolpaths() -- volumes is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(2));
	  const unsigned int alen = av_len(av)+1;
	  tool_colors = std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	    tmp = SvPV(*elem, len);
	      tool_colors[i] = std::string(tmp, len);
	    }
	    else
	      tool_colors[i] = std::string("");
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GUI::_3DScene::_load_print_toolpaths",
	             "tool_colors")
;
#line 655 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
        _3DScene::_load_print_toolpaths(print, volumes, tool_colors, use_VBOs != 0);
#line 24933 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__load_print_object_toolpaths); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__load_print_object_toolpaths)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "print_object, volumes, tool_colors, use_VBOs");
    {
	PrintObject *	print_object;
	GLVolumeCollection *	volumes;
	std::vector<std::string>	tool_colors;
	int	use_VBOs = (int)SvIV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(print_object) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(print_object) )) {
              print_object = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("print_object is not of type %s (got %s)", Slic3r::perl_class_name(print_object), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_load_print_object_toolpaths() -- print_object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(volumes) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(volumes) )) {
              volumes = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("volumes is not of type %s (got %s)", Slic3r::perl_class_name(volumes), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_load_print_object_toolpaths() -- volumes is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(2));
	  const unsigned int alen = av_len(av)+1;
	  tool_colors = std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	    tmp = SvPV(*elem, len);
	      tool_colors[i] = std::string(tmp, len);
	    }
	    else
	      tool_colors[i] = std::string("");
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GUI::_3DScene::_load_print_object_toolpaths",
	             "tool_colors")
;
#line 664 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
        _3DScene::_load_print_object_toolpaths(print_object, volumes, tool_colors, use_VBOs != 0);
#line 25002 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__load_wipe_tower_toolpaths); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__load_wipe_tower_toolpaths)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "print, volumes, tool_colors, use_VBOs");
    {
	Print *	print;
	GLVolumeCollection *	volumes;
	std::vector<std::string>	tool_colors;
	int	use_VBOs = (int)SvIV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(print) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(print) )) {
              print = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("print is not of type %s (got %s)", Slic3r::perl_class_name(print), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_load_wipe_tower_toolpaths() -- print is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(volumes) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(volumes) )) {
              volumes = (GLVolumeCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("volumes is not of type %s (got %s)", Slic3r::perl_class_name(volumes), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_load_wipe_tower_toolpaths() -- volumes is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(2));
	  const unsigned int alen = av_len(av)+1;
	  tool_colors = std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	    tmp = SvPV(*elem, len);
	      tool_colors[i] = std::string(tmp, len);
	    }
	    else
	      tool_colors[i] = std::string("");
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GUI::_3DScene::_load_wipe_tower_toolpaths",
	             "tool_colors")
;
#line 673 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp"
        _3DScene::_load_wipe_tower_toolpaths(print, volumes, tool_colors, use_VBOs != 0);
#line 25071 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI_3DScene.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "slic3r/GUI/GUI.hpp"

XS_EUPXS(XS_Slic3r__GUI_disable_screensaver); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI_disable_screensaver)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 18 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI.xsp"
     Slic3r::GUI::disable_screensaver(); 
#line 25095 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI_enable_screensaver); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI_enable_screensaver)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 23 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI.xsp"
     Slic3r::GUI::enable_screensaver(); 
#line 25110 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI_debugged); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI_debugged)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	bool	RETVAL;
	dXSTARG;
#line 28 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI.xsp"
     RETVAL=Slic3r::GUI::debugged(); 
#line 25127 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI_break_to_debugger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI_break_to_debugger)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 34 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI.xsp"
     Slic3r::GUI::break_to_debugger(); 
#line 25143 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GUI.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Geometry.hpp"

XS_EUPXS(XS_Slic3r__Geometry_arrange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_arrange)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "total_parts, part, dist, bb= NULL");
    {
	Pointfs	RETVAL;
	size_t	total_parts = (size_t)SvUV(ST(0))
;
	Pointf*	part;
	coordf_t	dist = (coordf_t)SvNV(ST(2))
;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(part) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(part) )) {
              part = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("part is not of type %s (got %s)", Slic3r::perl_class_name(part), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::arrange() -- part is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    bb = NULL;
	else {
    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
	if ( sv_isa(ST(3), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(bb) )) {
	      bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(3) ));
	} else {
	      croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(3)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Geometry::arrange() -- bb is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 18 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        Pointfs points;
        if (! Slic3r::Geometry::arrange(total_parts, *part, dist, bb, points))
            CONFESS(PRINTF_ZU " parts won't fit in your print area!\n", total_parts);
        RETVAL = points;
#line 25207 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Pointfs::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_directions_parallel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_directions_parallel)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "angle1, angle2");
    {
	double	angle1 = (double)SvNV(ST(0))
;
	double	angle2 = (double)SvNV(ST(1))
;
	bool	RETVAL;
	dXSTARG;
#line 31 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        RETVAL = Slic3r::Geometry::directions_parallel(angle1, angle2);
#line 25242 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_directions_parallel_within); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_directions_parallel_within)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "angle1, angle2, max_diff");
    {
	double	angle1 = (double)SvNV(ST(0))
;
	double	angle2 = (double)SvNV(ST(1))
;
	double	max_diff = (double)SvNV(ST(2))
;
	bool	RETVAL;
	dXSTARG;
#line 41 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        RETVAL = Slic3r::Geometry::directions_parallel(angle1, angle2, max_diff);
#line 25266 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_convex_hull); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_convex_hull)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "points");
    {
	Points	points;
	Clone<Polygon>	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::convex_hull",
	             "points")
;
#line 49 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        RETVAL = Slic3r::Geometry::convex_hull(points);
#line 25298 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_chained_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_chained_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "points");
    {
	Points	points;
	std::vector<Points::size_type>	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::chained_path",
	             "points")
;
#line 57 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        Slic3r::Geometry::chained_path(points, RETVAL);
#line 25337 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_chained_path_from); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_chained_path_from)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "points, start_from");
    {
	Points	points;
	Point*	start_from;
	std::vector<Points::size_type>	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::chained_path_from",
	             "points")
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(start_from) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(start_from) )) {
              start_from = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("start_from is not of type %s (got %s)", Slic3r::perl_class_name(start_from), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::chained_path_from() -- start_from is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 66 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        Slic3r::Geometry::chained_path(points, RETVAL, *start_from);
#line 25396 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_rad2deg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_rad2deg)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "angle");
    {
	double	angle = (double)SvNV(ST(0))
;
	double	RETVAL;
	dXSTARG;
#line 74 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        RETVAL = Slic3r::Geometry::rad2deg(angle);
#line 25429 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_rad2deg_dir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_rad2deg_dir)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "angle");
    {
	double	angle = (double)SvNV(ST(0))
;
	double	RETVAL;
	dXSTARG;
#line 82 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        RETVAL = Slic3r::Geometry::rad2deg_dir(angle);
#line 25449 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_deg2rad); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_deg2rad)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "angle");
    {
	double	angle = (double)SvNV(ST(0))
;
	double	RETVAL;
	dXSTARG;
#line 90 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        RETVAL = Slic3r::Geometry::deg2rad(angle);
#line 25469 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_simplify_polygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_simplify_polygons)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "polygons, tolerance");
    {
	Polygons	polygons;
	double	tolerance = (double)SvNV(ST(1))
;
	Polygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::simplify_polygons",
	             "polygons")
;
#line 99 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
        Slic3r::Geometry::simplify_polygons(polygons, tolerance, &RETVAL);
#line 25503 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 112 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp"
    RETVAL = ix;
#line 25535 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Geometry.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/GCodeSender.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__Sender_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GCodeSender *	RETVAL;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      RETVAL = new GCodeSender();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25573 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__Sender_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25620 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_connect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_connect)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, port, baud_rate");
    {
	GCodeSender *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	port;
	unsigned int	baud_rate = (unsigned int)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::connect() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      port = std::string(c, len);
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      RETVAL = THIS->connect( port, baud_rate );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25671 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_disconnect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_disconnect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::disconnect() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 65 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      THIS->disconnect();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25709 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_is_connected); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_is_connected)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::is_connected() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 78 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      RETVAL = THIS->is_connected();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25748 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_wait_connected); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_wait_connected)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, timeout= 3");
    {
	GCodeSender *	THIS;
	bool	RETVAL;
	dXSTARG;
	unsigned int	timeout;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::wait_connected() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    timeout = 3;
	else {
	    timeout = (unsigned int)SvUV(ST(1))
;
	}
#line 92 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      RETVAL = THIS->wait_connected( timeout );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25796 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_queue_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_queue_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::queue_size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 106 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      RETVAL = THIS->queue_size();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25836 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_send); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_send)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, s, priority= false");
    {
	GCodeSender *	THIS;
	std::string	s;
	bool	priority;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::send() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      s = std::string(c, len);
    }
;

	if (items < 3)
	    priority = false;
	else {
	    priority = (bool)SvUV(ST(2))
;
	}
#line 120 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      THIS->send( s, priority );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25892 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_pause_queue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_pause_queue)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::pause_queue() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 133 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      THIS->pause_queue();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25929 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_resume_queue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_resume_queue)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::resume_queue() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 146 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      THIS->resume_queue();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25966 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_purge_queue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_purge_queue)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, priority= false");
    {
	GCodeSender *	THIS;
	bool	priority;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::purge_queue() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    priority = false;
	else {
	    priority = (bool)SvUV(ST(1))
;
	}
#line 159 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      THIS->purge_queue( priority );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26011 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_purge_log); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_purge_log)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	std::vector<std::string>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::purge_log() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 172 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      RETVAL = THIS->purge_log();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26049 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_getT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_getT)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::getT() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 186 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      RETVAL = THIS->getT();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26103 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_getB); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_getB)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::getB() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 200 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp"
    try {
      RETVAL = THIS->getB();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26147 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCodeSender.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/GCode.hpp"
#include "libslic3r/GCode/CoolingBuffer.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, gcode");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	CoolingBuffer *	RETVAL;
	GCode*	gcode;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(gcode) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(gcode) )) {
              gcode = (GCode *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("gcode is not of type %s (got %s)", Slic3r::perl_class_name(gcode), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::new() -- gcode is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 22 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
     RETVAL = new CoolingBuffer(*gcode); 
#line 26197 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	CoolingBuffer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (CoolingBuffer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26244 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_gcodegen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_gcodegen)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	CoolingBuffer *	THIS;
	Ref<GCode>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (CoolingBuffer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::gcodegen() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
    try {
      RETVAL = THIS->gcodegen();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26282 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<GCode>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_process_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_process_layer)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, gcode, layer_id");
    {
	CoolingBuffer *	THIS;
	std::string	RETVAL;
	std::string	gcode;
	size_t	layer_id = (size_t)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (CoolingBuffer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::process_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      gcode = std::string(c, len);
    }
;
#line 58 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
    try {
      RETVAL = THIS->process_layer( gcode, layer_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26340 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GCode *	RETVAL;
#line 78 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
    try {
      RETVAL = new GCode();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26374 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 95 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26421 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_do_export); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_do_export)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, print, path");
    {
	GCode *	THIS;
	std::string	RETVAL;
	Print*	print;
	const char*	path = (const char *)SvPV_nolen(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::do_export() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print) )) {
              print = (Print *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print is not of type %s (got %s)", Slic3r::perl_class_name(print), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::do_export() -- print is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 108 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
    try {
      RETVAL = THIS->do_export( print, path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26475 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_origin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 122 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
     RETVAL = &(THIS->origin()); 
#line 26511 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_origin)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, pointf");
    {
	GCode *	THIS;
	Pointf*	pointf;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(pointf) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(pointf) )) {
              pointf = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("pointf is not of type %s (got %s)", Slic3r::perl_class_name(pointf), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_origin() -- pointf is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 128 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
     THIS->set_origin(*pointf); 
#line 26562 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_last_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_last_pos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::last_pos() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 133 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
     RETVAL = &(THIS->last_pos()); 
#line 26592 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	unsigned int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 139 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
    try {
      RETVAL = THIS->layer_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26639 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_layer_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	GCode *	THIS;
	unsigned int	value = (unsigned int)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 153 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
    try {
      THIS->set_layer_count( value );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26679 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_set_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_extruders)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, extruders");
    {
	GCode *	THIS;
	std::vector< unsigned int >	extruders;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  extruders = std::vector<unsigned int>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      extruders[i] = SvUV(*elem);
	    else
	      extruders[i] = 0;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GCode::set_extruders",
	             "extruders")
;
#line 166 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
     THIS->writer().set_extruders(extruders); THIS->writer().set_extruder(0); 
#line 26728 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_apply_print_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_apply_print_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, print_config");
    {
	GCode *	THIS;
	StaticPrintConfig*	print_config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::apply_print_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print_config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print_config) )) {
              print_config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print_config is not of type %s (got %s)", Slic3r::perl_class_name(print_config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::apply_print_config() -- print_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 171 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
            if (const PrintConfig* config = dynamic_cast<PrintConfig*>(print_config)) {
                THIS->apply_print_config(*config);
            } else {
                CONFESS("A PrintConfig object was not supplied to apply_print_config()");
            }
#line 26775 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 180 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp"
     RETVAL = const_cast<StaticPrintConfig*>(dynamic_cast<const StaticPrintConfig*>(&THIS->config())); 
#line 26805 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/GCode.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Flow.hpp"

XS_EUPXS(XS_Slic3r__Flow_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26859 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Flow__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow__new)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "CLASS, width, height, nozzle_diameter");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Flow *	RETVAL;
	float	width = (float)SvNV(ST(1))
;
	float	height = (float)SvNV(ST(2))
;
	float	nozzle_diameter = (float)SvNV(ST(3))
;
#line 34 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
    try {
      RETVAL = new Flow( width, height, nozzle_diameter );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26893 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Flow_set_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_set_height)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, height");
    {
	Flow *	THIS;
	float	height = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::set_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
     THIS->height = height; 
#line 26934 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Flow_set_bridge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_set_bridge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bridge");
    {
	Flow *	THIS;
	bool	bridge = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::set_bridge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
     THIS->bridge = bridge; 
#line 26965 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Flow_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	Clone<Flow>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 61 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
     RETVAL = THIS; 
#line 26995 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 67 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
     RETVAL = THIS->width; 
#line 27034 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
     RETVAL = THIS->height; 
#line 27066 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_nozzle_diameter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_nozzle_diameter)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::nozzle_diameter() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 79 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
     RETVAL = THIS->nozzle_diameter; 
#line 27098 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_bridge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_bridge)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::bridge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 85 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
     RETVAL = THIS->bridge; 
#line 27130 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
    try {
      RETVAL = THIS->spacing();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 27170 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_spacing_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_spacing_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;
	Flow*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::spacing_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::spacing_to() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 105 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
     RETVAL = THIS->spacing(*other); 
#line 27216 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_scaled_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_scaled_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::scaled_width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 111 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
    try {
      RETVAL = THIS->scaled_width();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 27256 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_scaled_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_scaled_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::scaled_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 125 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
    try {
      RETVAL = THIS->scaled_spacing();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 27296 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_mm3_per_mm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_mm3_per_mm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::mm3_per_mm() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 139 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
    try {
      RETVAL = THIS->mm3_per_mm();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 27336 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow__new_from_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow__new_from_width)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "CLASS, role, width, nozzle_diameter, height, bridge_flow_ratio");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	FlowRole	role = (FlowRole)SvUV(ST(1))
;
	std::string	width;
	float	nozzle_diameter = (float)SvNV(ST(3))
;
	float	height = (float)SvNV(ST(4))
;
	float	bridge_flow_ratio = (float)SvNV(ST(5))
;
	Flow *	RETVAL;

    {
      size_t len;
      // const char * c = SvPV(ST(2), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(2), len);
      width = std::string(c, len);
    }
;
#line 161 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
        ConfigOptionFloatOrPercent optwidth;
        optwidth.deserialize(width);
        RETVAL = new Flow(Flow::new_from_config_width(role, optwidth, nozzle_diameter, height, bridge_flow_ratio));
#line 27375 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow__new_from_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow__new_from_spacing)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "CLASS, spacing, nozzle_diameter, height, bridge");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	float	spacing = (float)SvNV(ST(1))
;
	float	nozzle_diameter = (float)SvNV(ST(2))
;
	float	height = (float)SvNV(ST(3))
;
	bool	bridge = (bool)SvUV(ST(4))
;
	Flow *	RETVAL;
#line 175 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
        RETVAL = new Flow(Flow::new_from_spacing(spacing, nozzle_diameter, height, bridge));
#line 27409 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 198 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp"
    RETVAL = ix;
#line 27435 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Flow.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Fill/Fill.hpp"
#include "libslic3r/PolylineCollection.hpp"
#include "libslic3r/ExtrusionEntity.hpp"
#include "libslic3r/ExtrusionEntityCollection.hpp"

XS_EUPXS(XS_Slic3r__Filler_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 27485 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bbox");
    {
	Filler *	THIS;
	BoundingBox*	bbox;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bbox) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bbox) )) {
              bbox = (BoundingBox *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bbox is not of type %s (got %s)", Slic3r::perl_class_name(bbox), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_bounding_box() -- bbox is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 34 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->fill->set_bounding_box(*bbox); 
#line 27528 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_spacing)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, spacing");
    {
	Filler *	THIS;
	coordf_t	spacing = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->fill->spacing = spacing; 
#line 27559 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     RETVAL = THIS->fill->spacing; 
#line 27590 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_set_layer_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_layer_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer_id");
    {
	Filler *	THIS;
	size_t	layer_id = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_layer_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 50 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->fill->layer_id = layer_id; 
#line 27622 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_z)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	Filler *	THIS;
	coordf_t	z = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 55 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->fill->z = z; 
#line 27653 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_angle)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	Filler *	THIS;
	float	angle = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 60 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->fill->angle = angle; 
#line 27684 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_link_max_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_link_max_length)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, len");
    {
	Filler *	THIS;
	coordf_t	len = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_link_max_length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 65 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->fill->link_max_length = len; 
#line 27715 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_loop_clipping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_loop_clipping)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, clipping");
    {
	Filler *	THIS;
	coordf_t	clipping = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_loop_clipping() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 70 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->fill->loop_clipping = clipping; 
#line 27746 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_use_bridge_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_use_bridge_flow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::use_bridge_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 75 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     RETVAL = THIS->fill->use_bridge_flow(); 
#line 27777 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_no_sort); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_no_sort)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::no_sort() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 81 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     RETVAL = THIS->fill->no_sort(); 
#line 27809 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_set_density); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_density)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, density");
    {
	Filler *	THIS;
	float	density = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_density() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 87 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->params.density = density; 
#line 27841 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_dont_connect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_dont_connect)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, dont_connect");
    {
	Filler *	THIS;
	bool	dont_connect = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_dont_connect() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 92 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->params.dont_connect = dont_connect; 
#line 27872 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_dont_adjust); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_dont_adjust)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, dont_adjust");
    {
	Filler *	THIS;
	bool	dont_adjust = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_dont_adjust() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 97 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->params.dont_adjust = dont_adjust; 
#line 27903 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_complete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_complete)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, complete");
    {
	Filler *	THIS;
	bool	complete = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_complete() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 102 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
     THIS->params.complete = complete; 
#line 27934 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler__fill_surface); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler__fill_surface)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, surface");
    {
	Filler *	THIS;
	PolylineCollection *	RETVAL;
	Surface*	surface;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::_fill_surface() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(surface) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(surface) )) {
              surface = (Surface *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("surface is not of type %s (got %s)", Slic3r::perl_class_name(surface), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::_fill_surface() -- surface is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 107 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
            PolylineCollection *pc = NULL;
            if (THIS->fill != NULL) {
                pc = new PolylineCollection();
                pc->polylines = THIS->fill->fill_surface(surface, THIS->params);
            }
            RETVAL =  pc;
#line 27983 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_new_from_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_new_from_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, type");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	std::string	type;
	Filler *	RETVAL;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      type = std::string(c, len);
    }
;
#line 122 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
        Filler *filler = new Filler();
        filler->fill = Fill::new_from_type(type);
        RETVAL = filler;
#line 28021 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_make_fill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_make_fill)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "CLASS, layer_region, out_append");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	LayerRegion*	layer_region;
	ExtrusionEntityCollection*	out_append;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer_region) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer_region) )) {
              layer_region = (LayerRegion *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer_region is not of type %s (got %s)", Slic3r::perl_class_name(layer_region), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::make_fill() -- layer_region is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(out_append) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(out_append) )) {
              out_append = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("out_append is not of type %s (got %s)", Slic3r::perl_class_name(out_append), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::make_fill() -- out_append is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 134 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp"
        make_fill(*layer_region, *out_append);
#line 28074 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Filler.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExtrusionSimulator.hpp"

XS_EUPXS(XS_Slic3r__ExtrusionSimulator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionSimulator *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28120 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__ExtrusionSimulator__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator__new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExtrusionSimulator *	RETVAL;
#line 34 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
    try {
      RETVAL = new ExtrusionSimulator();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28148 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__ExtrusionSimulator_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionSimulator *	THIS;
	Clone<ExtrusionSimulator>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
     RETVAL = THIS; 
#line 28188 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExtrusionSimulator>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionSimulator_set_image_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_set_image_size)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, image_size");
    {
	ExtrusionSimulator *	THIS;
	Point*	image_size;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::set_image_size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(image_size) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(image_size) )) {
              image_size = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("image_size is not of type %s (got %s)", Slic3r::perl_class_name(image_size), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::set_image_size() -- image_size is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
     THIS->set_image_size(*image_size); 
#line 28239 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionSimulator_set_viewport); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_set_viewport)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, viewport");
    {
	ExtrusionSimulator *	THIS;
	BoundingBox*	viewport;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::set_viewport() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(viewport) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(viewport) )) {
              viewport = (BoundingBox *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("viewport is not of type %s (got %s)", Slic3r::perl_class_name(viewport), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::set_viewport() -- viewport is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
     THIS->set_viewport(*viewport); 
#line 28282 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionSimulator_set_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_set_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bbox");
    {
	ExtrusionSimulator *	THIS;
	BoundingBox*	bbox;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::set_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bbox) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bbox) )) {
              bbox = (BoundingBox *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bbox is not of type %s (got %s)", Slic3r::perl_class_name(bbox), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::set_bounding_box() -- bbox is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 67 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
     THIS->set_bounding_box(*bbox); 
#line 28325 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionSimulator_reset_accumulator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_reset_accumulator)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionSimulator *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::reset_accumulator() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 72 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
    try {
      THIS->reset_accumulator();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28362 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionSimulator_extrude_to_accumulator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_extrude_to_accumulator)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, path, shift, simulationType");
    {
	ExtrusionSimulator *	THIS;
	ExtrusionPath*	path;
	Point*	shift;
	ExtrusionSimulationType	simulationType = (ExtrusionSimulationType)SvUV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::extrude_to_accumulator() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(path) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(path) )) {
              path = (ExtrusionPath *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("path is not of type %s (got %s)", Slic3r::perl_class_name(path), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::extrude_to_accumulator() -- path is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(shift) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(shift) )) {
              shift = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("shift is not of type %s (got %s)", Slic3r::perl_class_name(shift), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::extrude_to_accumulator() -- shift is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 85 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
     THIS->extrude_to_accumulator(*path, *shift, simulationType); 
#line 28421 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionSimulator_evaluate_accumulator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_evaluate_accumulator)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, simulationType");
    {
	ExtrusionSimulator *	THIS;
	ExtrusionSimulationType	simulationType = (ExtrusionSimulationType)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::evaluate_accumulator() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 90 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
    try {
    simulationType = (ExtrusionSimulationType)SvUV(ST(1));
  ;
      THIS->evaluate_accumulator( simulationType );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28462 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionSimulator_image_ptr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator_image_ptr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionSimulator *	THIS;
	void *	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionSimulator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionSimulator::image_ptr() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 105 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
     RETVAL = const_cast<void*>(const_cast<Slic3r::ExtrusionSimulator*>(THIS)->image_ptr()); 
#line 28493 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionSimulator__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionSimulator__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 127 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp"
    RETVAL = ix;
#line 28512 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionSimulator.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExtrusionEntity.hpp"
#include "libslic3r/ExtrusionEntityCollection.hpp"

XS_EUPXS(XS_Slic3r__ExtrusionPath_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 19 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28560 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 32 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
     RETVAL = to_AV(&THIS->polyline); 
#line 28590 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
     RETVAL = to_SV_pureperl(&THIS->polyline); 
#line 28622 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_pop_back); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_pop_back)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::pop_back() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
     THIS->polyline.points.pop_back(); 
#line 28653 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 49 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28690 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_lines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_lines)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Lines	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::lines() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
     RETVAL = THIS->polyline.lines(); 
#line 28720 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Lines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 68 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28772 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28818 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_clip_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_clip_end)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	ExtrusionPath *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::clip_end() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 96 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      THIS->clip_end( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28865 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	ExtrusionPath *	THIS;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28904 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 122 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28943 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_role); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_role)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	ExtrusionRole	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::role() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 136 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      RETVAL = THIS->role();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28983 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_is_bridge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_is_bridge)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::is_bridge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 150 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
     RETVAL = is_bridge(THIS->role()); 
#line 29015 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_polygons_covered_by_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_polygons_covered_by_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::polygons_covered_by_width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 156 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      RETVAL = THIS->polygons_covered_by_width();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29054 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_polygons_covered_by_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_polygons_covered_by_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::polygons_covered_by_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 170 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    try {
      RETVAL = THIS->polygons_covered_by_spacing();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29106 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__new)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "CLASS, polyline_sv, role, mm3_per_mm, width, height");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	SV*	polyline_sv = ST(1)
;
	ExtrusionRole	role = (ExtrusionRole)SvUV(ST(2))
;
	double	mm3_per_mm = (double)SvNV(ST(3))
;
	float	width = (float)SvNV(ST(4))
;
	float	height = (float)SvNV(ST(5))
;
	ExtrusionPath *	RETVAL;
#line 192 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
        RETVAL = new ExtrusionPath (role);
        from_SV_check(polyline_sv, &RETVAL->polyline);
        RETVAL->mm3_per_mm      = mm3_per_mm;
        RETVAL->width           = width;
        RETVAL->height          = height;
#line 29152 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_polyline)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	Ref<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 203 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
        if (items > 1) {
            from_SV_check(ST(1), &THIS->polyline);
        }
        RETVAL = &(THIS->polyline);
#line 29193 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_mm3_per_mm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_mm3_per_mm)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::mm3_per_mm() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 213 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
        if (items > 1) {
            THIS->mm3_per_mm = (double)SvNV(ST(1));
        }
        RETVAL = THIS->mm3_per_mm;
#line 29235 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_width)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 223 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
        if (items > 1) {
            THIS->width = (float)SvNV(ST(1));
        }
        RETVAL = THIS->width;
#line 29270 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_height)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 233 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
        if (items > 1) {
            THIS->height = (float)SvNV(ST(1));
        }
        RETVAL = THIS->height;
#line 29305 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 243 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
        for (unsigned int i = 1; i < items; i++) {
            Point p;
            from_SV_check(ST(i), &p);
            THIS->polyline.points.push_back(p);
        }
#line 29339 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_intersect_expolygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_intersect_expolygons)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, collection");
    {
	ExtrusionPath *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	ExPolygonCollection*	collection;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::intersect_expolygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(collection) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(collection) )) {
              collection = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("collection is not of type %s (got %s)", Slic3r::perl_class_name(collection), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::intersect_expolygons() -- collection is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 252 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
        RETVAL = new ExtrusionEntityCollection ();
        THIS->intersect_expolygons(*collection, RETVAL);
#line 29384 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_subtract_expolygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_subtract_expolygons)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, collection");
    {
	ExtrusionPath *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	ExPolygonCollection*	collection;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::subtract_expolygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(collection) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(collection) )) {
              collection = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("collection is not of type %s (got %s)", Slic3r::perl_class_name(collection), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::subtract_expolygons() -- collection is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 260 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
        RETVAL = new ExtrusionEntityCollection ();
        THIS->subtract_expolygons(*collection, RETVAL);
#line 29437 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 290 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp"
    RETVAL = ix;
#line 29463 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionPath.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExtrusionEntity.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExtrusionMultiPath *	RETVAL;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
    try {
      RETVAL = new ExtrusionMultiPath();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29501 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29548 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;
	Clone<ExtrusionMultiPath>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
     RETVAL = THIS; 
#line 29578 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExtrusionMultiPath>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29623 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 70 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29661 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 84 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29707 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_append)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	ExtrusionMultiPath *	THIS;
	ExtrusionPath*	path;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(path) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(path) )) {
              path = (ExtrusionPath *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("path is not of type %s (got %s)", Slic3r::perl_class_name(path), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::append() -- path is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 98 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
     THIS->paths.push_back(*path); 
#line 29758 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 103 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29797 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_polygons_covered_by_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_polygons_covered_by_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::polygons_covered_by_width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 117 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
    try {
      RETVAL = THIS->polygons_covered_by_width();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29836 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_polygons_covered_by_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_polygons_covered_by_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::polygons_covered_by_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 131 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
    try {
      RETVAL = THIS->polygons_covered_by_spacing();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29888 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_polyline)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 145 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
     RETVAL = THIS->as_polyline(); 
#line 29932 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionMultiPath_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionMultiPath *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionMultiPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionMultiPath::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 153 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp"
        AV* av = newAV();
        av_fill(av, THIS->paths.size()-1);
        for (ExtrusionPaths::iterator it = THIS->paths.begin(); it != THIS->paths.end(); ++it) {
            av_store(av, it - THIS->paths.begin(), perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 29975 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionMultiPath.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExtrusionEntity.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__ExtrusionLoop_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExtrusionLoop *	RETVAL;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = new ExtrusionLoop();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30014 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__ExtrusionLoop_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30061 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<ExtrusionLoop>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
     RETVAL = THIS; 
#line 30091 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExtrusionLoop>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30136 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_make_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_make_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::make_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 70 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->make_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30175 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_make_counter_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_make_counter_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::make_counter_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 84 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->make_counter_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30215 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 98 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30254 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 112 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30300 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_polygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_polygon)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::polygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 126 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->polygon();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30346 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_append)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	ExtrusionLoop *	THIS;
	ExtrusionPath*	path;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(path) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(path) )) {
              path = (ExtrusionPath *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("path is not of type %s (got %s)", Slic3r::perl_class_name(path), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::append() -- path is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 140 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
     THIS->paths.push_back(*path); 
#line 30397 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 145 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30436 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_split_at_vertex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_split_at_vertex)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::split_at_vertex() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::split_at_vertex() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 159 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
     RETVAL = THIS->split_at_vertex(*point); 
#line 30482 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_split_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_split_at)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, point, prefer_non_overhang= 0");
    {
	ExtrusionLoop *	THIS;
	Point*	point;
	int	prefer_non_overhang;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::split_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::split_at() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    prefer_non_overhang = 0;
	else {
	    prefer_non_overhang = (int)SvIV(ST(2))
;
	}
#line 165 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
     THIS->split_at(*point, prefer_non_overhang != 0); 
#line 30534 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_clip_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_clip_end)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	ExtrusionLoop *	THIS;
	ExtrusionPaths	RETVAL;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::clip_end() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 170 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
     THIS->clip_end(distance, &RETVAL); 
#line 30566 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExtrusionPaths::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_has_overhang_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_has_overhang_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::has_overhang_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::has_overhang_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 176 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
     RETVAL = THIS->has_overhang_point(*point); 
#line 30625 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_role); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_role)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	ExtrusionRole	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::role() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 182 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->role();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30665 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_loop_role); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_loop_role)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	ExtrusionLoopRole	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::loop_role() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 196 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->loop_role();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30705 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_polygons_covered_by_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_polygons_covered_by_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::polygons_covered_by_width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 210 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->polygons_covered_by_width();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30744 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_polygons_covered_by_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_polygons_covered_by_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::polygons_covered_by_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 224 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    try {
      RETVAL = THIS->polygons_covered_by_spacing();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30796 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 240 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
        AV* av = newAV();
        av_fill(av, THIS->paths.size()-1);
        for (ExtrusionPaths::iterator it = THIS->paths.begin(); it != THIS->paths.end(); ++it) {
            av_store(av, it - THIS->paths.begin(), perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 30845 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 264 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp"
    RETVAL = ix;
#line 30865 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionLoop.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExtrusionEntityCollection.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection__new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExtrusionEntityCollection *	RETVAL;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      RETVAL = new ExtrusionEntityCollection();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30903 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30950 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Clone<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
     RETVAL = THIS->clone(); 
#line 30980 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31025 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 70 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      THIS->clear();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31062 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, no_reverse, role= erMixed");
    {
	ExtrusionEntityCollection *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	bool	no_reverse = (bool)SvUV(ST(1))
;
	ExtrusionRole	role;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::chained_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    role = erMixed;
	else {
	    role = (ExtrusionRole)SvUV(ST(2))
;
	}
#line 83 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
            RETVAL = new ExtrusionEntityCollection();
            THIS->chained_path(RETVAL, no_reverse, role);
#line 31103 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path_from); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path_from)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, start_near, no_reverse, role= erMixed");
    {
	ExtrusionEntityCollection *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	Point*	start_near;
	bool	no_reverse = (bool)SvUV(ST(2))
;
	ExtrusionRole	role;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::chained_path_from() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(start_near) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(start_near) )) {
              start_near = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("start_near is not of type %s (got %s)", Slic3r::perl_class_name(start_near), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::chained_path_from() -- start_near is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    role = erMixed;
	else {
	    role = (ExtrusionRole)SvUV(ST(3))
;
	}
#line 90 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
            RETVAL = new ExtrusionEntityCollection();
            THIS->chained_path_from(*start_near, RETVAL, no_reverse, role);
#line 31166 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 97 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31212 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 111 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31258 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 125 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
     RETVAL = THIS->entities.size(); 
#line 31297 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_items_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_items_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::items_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 131 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
     RETVAL = THIS->items_count(); 
#line 31329 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_flatten); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_flatten)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	ExtrusionEntityCollection *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::flatten() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 137 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
            RETVAL = new ExtrusionEntityCollection();
            THIS->flatten(RETVAL);
#line 31361 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_min_mm3_per_mm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_min_mm3_per_mm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::min_mm3_per_mm() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 144 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      RETVAL = THIS->min_mm3_per_mm();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31408 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::empty() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 158 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
     RETVAL = THIS->entities.empty(); 
#line 31440 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_orig_indices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_orig_indices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	std::vector<size_t>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::orig_indices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 164 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
     RETVAL = THIS->orig_indices; 
#line 31471 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_polygons_covered_by_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_polygons_covered_by_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::polygons_covered_by_width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 170 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      RETVAL = THIS->polygons_covered_by_width();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31523 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_polygons_covered_by_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_polygons_covered_by_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::polygons_covered_by_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 184 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
    try {
      RETVAL = THIS->polygons_covered_by_spacing();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31575 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 200 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
        AV* av = newAV();
        av_fill(av, THIS->entities.size()-1);
        int i = 0;
        for (ExtrusionEntitiesPtr::iterator it = THIS->entities.begin(); it != THIS->entities.end(); ++it) {
            SV* sv = newSV(0);
            // return our item by reference
            if (ExtrusionPath* path = dynamic_cast<ExtrusionPath*>(*it)) {
                sv_setref_pv( sv, perl_class_name_ref(path), path );
            } else if (ExtrusionMultiPath* multipath = dynamic_cast<ExtrusionMultiPath*>(*it)) {
                sv_setref_pv( sv, perl_class_name_ref(multipath), multipath );
            } else if (ExtrusionLoop* loop = dynamic_cast<ExtrusionLoop*>(*it)) {
                sv_setref_pv( sv, perl_class_name_ref(loop), loop );
            } else if (ExtrusionEntityCollection* collection = dynamic_cast<ExtrusionEntityCollection*>(*it)) {
                sv_setref_pv( sv, perl_class_name_ref(collection), collection );
            } else {
                croak("Unexpected type in ExtrusionEntityCollection");
            }
            av_store(av, i++, sv);
        }
        RETVAL = newRV_noinc((SV*)av);
#line 31638 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionEntityCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 226 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
        for (unsigned int i = 1; i < items; i++) {
            if(!sv_isobject( ST(i) ) || (SvTYPE(SvRV( ST(i) )) != SVt_PVMG)) {
                croak("Argument %d is not object", i);
            }
            ExtrusionEntity* entity = (ExtrusionEntity *)SvIV((SV*)SvRV( ST(i) ));
            // append COPIES
            if (ExtrusionPath* path = dynamic_cast<ExtrusionPath*>(entity)) {
                THIS->entities.push_back( new ExtrusionPath(*path) );
            } else if (ExtrusionMultiPath* multipath = dynamic_cast<ExtrusionMultiPath*>(entity)) {
                THIS->entities.push_back( new ExtrusionMultiPath(*multipath) );
            } else if (ExtrusionLoop* loop = dynamic_cast<ExtrusionLoop*>(entity)) {
                THIS->entities.push_back( new ExtrusionLoop(*loop) );
            } else if(ExtrusionEntityCollection* collection = dynamic_cast<ExtrusionEntityCollection*>(entity)) {
                THIS->entities.push_back( collection->clone() );
            } else {
                croak("Argument %d is of unknown type", i);
            }
        }
#line 31686 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_no_sort); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_no_sort)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionEntityCollection *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::no_sort() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 248 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"
        if (items > 1) {
            THIS->no_sort = SvTRUE(ST(1));
        }
        RETVAL = THIS->no_sort;
#line 31720 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExPolygonCollection.hpp"

XS_EUPXS(XS_Slic3r__ExPolygon__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31767 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	Clone<ExPolygonCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
     RETVAL = THIS; 
#line 31797 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExPolygonCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 37 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
     THIS->expolygons.clear(); 
#line 31834 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	ExPolygonCollection *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 42 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31873 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	ExPolygonCollection *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 55 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31914 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center");
    {
	ExPolygonCollection *	THIS;
	double	angle = (double)SvNV(ST(1))
;
	Point*	center;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(center) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(center) )) {
              center = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("center is not of type %s (got %s)", Slic3r::perl_class_name(center), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::rotate() -- center is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 68 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
     THIS->rotate(angle, *center); 
#line 31959 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
     RETVAL = THIS->expolygons.size(); 
#line 31990 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ExPolygonCollection *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 79 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
     RETVAL = THIS->contains(*point); 
#line 32036 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	ExPolygonCollection *	THIS;
	bool	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 85 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
     RETVAL = THIS->contains(*line); 
#line 32082 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	ExPolygonCollection *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
     RETVAL = THIS->contains(*polyline); 
#line 32128 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	ExPolygonCollection *	THIS;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 97 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
    try {
      THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32168 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_polygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_polygons)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::polygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 110 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
     RETVAL = *THIS; 
#line 32198 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_convex_hull); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_convex_hull)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::convex_hull() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 116 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
    try {
      RETVAL = THIS->convex_hull();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32250 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExPolygonCollection *	RETVAL;
#line 132 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
        RETVAL = new ExPolygonCollection ();
        // ST(0) is class name, others are expolygons
        RETVAL->expolygons.resize(items-1);
        for (unsigned int i = 1; i < items; i++) {
            // Note: a COPY of the input is stored
            from_SV_check(ST(i), &RETVAL->expolygons[i-1]);
        }
#line 32282 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 145 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
        AV* av = newAV();
        av_fill(av, THIS->expolygons.size()-1);
        int i = 0;
        for (ExPolygons::iterator it = THIS->expolygons.begin(); it != THIS->expolygons.end(); ++it) {
            av_store(av, i++, perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 32326 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 158 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
        AV* av = newAV();
        av_fill(av, THIS->expolygons.size()-1);
        int i = 0;
        for (ExPolygons::iterator it = THIS->expolygons.begin(); it != THIS->expolygons.end(); ++it) {
            av_store(av, i++, to_SV_pureperl(&*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 32364 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExPolygonCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 171 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp"
        for (unsigned int i = 1; i < items; i++) {
            ExPolygon expolygon;
            from_SV_check(ST(i), &expolygon);
            THIS->expolygons.push_back(expolygon);
        }
#line 32399 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygonCollection.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExPolygon.hpp"

XS_EUPXS(XS_Slic3r__ExPolygon_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32445 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Clone<ExPolygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     RETVAL = THIS; 
#line 32475 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExPolygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 37 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     RETVAL = to_AV(THIS); 
#line 32513 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 43 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     RETVAL = to_SV_pureperl(THIS); 
#line 32545 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_contour); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_contour)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Ref<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contour() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 49 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     RETVAL = &(THIS->contour); 
#line 32577 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_holes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_holes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Polygons *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::holes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 55 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     RETVAL = &(THIS->holes); 
#line 32615 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	ExPolygon *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 61 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32668 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	ExPolygon *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 74 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32709 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon_area); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_area)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::area() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 87 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
    try {
      RETVAL = THIS->area();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32748 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::is_valid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 101 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
    try {
      RETVAL = THIS->is_valid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32788 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_contains_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_contains_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	ExPolygon *	THIS;
	bool	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 115 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     RETVAL = THIS->contains(*line); 
#line 32834 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_contains_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_contains_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	ExPolygon *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 121 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     RETVAL = THIS->contains(*polyline); 
#line 32880 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ExPolygon *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 127 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     RETVAL = THIS->contains(*point); 
#line 32926 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	ExPolygon *	THIS;
	ExPolygons	RETVAL;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 133 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
    try {
      RETVAL = THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32967 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_simplify_p); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_simplify_p)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::simplify_p() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 147 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
    try {
      RETVAL = THIS->simplify_p( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33021 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_medial_axis); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_medial_axis)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, max_width, min_width");
    {
	ExPolygon *	THIS;
	Polylines	RETVAL;
	double	max_width = (double)SvNV(ST(1))
;
	double	min_width = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::medial_axis() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 161 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     THIS->medial_axis(max_width, min_width, &RETVAL); 
#line 33069 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_get_trapezoids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_get_trapezoids)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::get_trapezoids() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 167 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     THIS->get_trapezoids(&RETVAL, angle); 
#line 33115 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_get_trapezoids2); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_get_trapezoids2)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::get_trapezoids2() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 173 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     THIS->get_trapezoids2(&RETVAL, angle); 
#line 33161 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_triangulate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_triangulate)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::triangulate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 179 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     THIS->triangulate(&RETVAL); 
#line 33205 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_triangulate_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_triangulate_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::triangulate_pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 185 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
     THIS->triangulate_pp(&RETVAL); 
#line 33249 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExPolygon *	RETVAL;
#line 193 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
        RETVAL = new ExPolygon ();
        // ST(0) is class name, ST(1) is contour and others are holes
        from_SV_check(ST(1), &RETVAL->contour);
        RETVAL->holes.resize(items-2);
        for (unsigned int i = 2; i < items; i++) {
            from_SV_check(ST(i), &RETVAL->holes[i-2]);
        }
#line 33287 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	ExPolygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 208 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp"
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 33330 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/ExPolygon.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/PrintConfig.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Config_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	DynamicPrintConfig *	RETVAL;
#line 21 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = new DynamicPrintConfig();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33367 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Config_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33414 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_has); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_has)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::has() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 51 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->has( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33463 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_as_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_as_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::as_hash() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 65 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__as_hash(THIS); 
#line 33494 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	SV *	RETVAL;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 71 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__get(THIS, opt_key); 
#line 33536 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_get_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get_at)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, i");
    {
	DynamicPrintConfig *	THIS;
	SV *	RETVAL;
	t_config_option_key	opt_key;
	int	i = (int)SvIV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 77 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__get_at(THIS, opt_key, i); 
#line 33580 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, value");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	SV*	value = ST(2)
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::set() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 83 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__set(THIS, opt_key, value); 
#line 33625 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_set_deserialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_set_deserialize)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, str");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	SV*	str = ST(2)
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::set_deserialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 89 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__set_deserialize(THIS, opt_key, str); 
#line 33669 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_set_ifndef); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_set_ifndef)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, opt_key, value, deserialize= false");
    {
	DynamicPrintConfig *	THIS;
	t_config_option_key	opt_key;
	SV*	value = ST(2)
;
	bool	deserialize;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::set_ifndef() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;

	if (items < 4)
	    deserialize = false;
	else {
	    deserialize = (bool)SvUV(ST(3))
;
	}
#line 95 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     ConfigBase__set_ifndef(THIS, opt_key, value, deserialize); 
#line 33719 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_serialize)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	std::string	RETVAL;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 100 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->serialize( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33767 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_get_abs_value); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get_abs_value)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get_abs_value() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 114 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->get_abs_value( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33822 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_get_abs_value_over); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get_abs_value_over)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, ratio_over");
    {
	DynamicPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	double	ratio_over = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get_abs_value_over() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 128 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->get_abs_value( opt_key, ratio_over );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33874 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_apply); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_apply)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	DynamicPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 142 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     THIS->apply(*other, true); 
#line 33918 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_diff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_diff)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	std::vector<std::string>	RETVAL;
	DynamicPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::diff() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::diff() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 147 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = THIS->diff(*other); 
#line 33962 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_equals); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_equals)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	DynamicPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::equals() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::equals() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 153 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = THIS->equals(*other); 
#line 34023 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_apply_static); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_apply_static)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	StaticPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply_static() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply_static() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 159 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     THIS->apply(*other, true); 
#line 34067 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_get_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get_keys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;
	std::vector<std::string>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get_keys() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 164 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->keys();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34105 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_erase); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_erase)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::erase() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 178 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->erase( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34168 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_normalize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_normalize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::normalize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 191 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->normalize();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34205 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_setenv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_setenv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::setenv() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 204 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->setenv_();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34242 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_min_object_distance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_min_object_distance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::min_object_distance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 217 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->min_object_distance();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34281 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	DynamicPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::_load() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 231 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->load( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34329 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__load_from_gcode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__load_from_gcode)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, input_file");
    {
	DynamicPrintConfig *	THIS;
	std::string	input_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::_load_from_gcode() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      input_file = std::string(c, len);
    }
;
#line 244 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
            try {
                THIS->load_from_gcode(input_file);
            } catch (std::exception& e) {
                croak("Error extracting configuration from a g-code %s:\n%s\n", input_file.c_str(), e.what());
            }
#line 34372 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__save); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__save)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	DynamicPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::_save() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 253 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->save( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34419 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_new_GCodeConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_GCodeConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 269 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = new GCodeConfig (); 
#line 34435 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_PrintConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_PrintConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 275 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = new PrintConfig (); 
#line 34459 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_PrintObjectConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_PrintObjectConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 281 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = new PrintObjectConfig (); 
#line 34483 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_PrintRegionConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_PrintRegionConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 287 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = new PrintRegionConfig (); 
#line 34507 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_FullPrintConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_FullPrintConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 293 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = new FullPrintConfig (); 
#line 34531 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 299 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34576 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_has); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_has)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	StaticPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::has() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 312 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->has( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34625 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_as_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_as_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::as_hash() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 326 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__as_hash(THIS); 
#line 34656 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	StaticPrintConfig *	THIS;
	SV *	RETVAL;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 332 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__get(THIS, opt_key); 
#line 34698 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_at)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, i");
    {
	StaticPrintConfig *	THIS;
	SV *	RETVAL;
	t_config_option_key	opt_key;
	int	i = (int)SvIV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 338 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__get_at(THIS, opt_key, i); 
#line 34742 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, value");
    {
	StaticPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	SV*	value = ST(2)
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::set() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 344 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = StaticConfig__set(THIS, opt_key, value); 
#line 34787 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_set_deserialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_set_deserialize)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, str");
    {
	StaticPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	SV*	str = ST(2)
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::set_deserialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 350 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     RETVAL = ConfigBase__set_deserialize(THIS, opt_key, str); 
#line 34831 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_set_ifndef); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_set_ifndef)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, opt_key, value, deserialize= false");
    {
	StaticPrintConfig *	THIS;
	t_config_option_key	opt_key;
	SV*	value = ST(2)
;
	bool	deserialize;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::set_ifndef() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;

	if (items < 4)
	    deserialize = false;
	else {
	    deserialize = (bool)SvUV(ST(3))
;
	}
#line 356 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     ConfigBase__set_ifndef(THIS, opt_key, value, deserialize); 
#line 34881 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_serialize)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	StaticPrintConfig *	THIS;
	std::string	RETVAL;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 361 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->serialize( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34929 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get_abs_value); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_abs_value)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	StaticPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_abs_value() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 375 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->get_abs_value( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34984 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get_abs_value_over); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_abs_value_over)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, ratio_over");
    {
	StaticPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	double	ratio_over = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_abs_value_over() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 389 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->get_abs_value( opt_key, ratio_over );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35036 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_apply_static); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_apply_static)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	StaticPrintConfig *	THIS;
	StaticPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::apply_static() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::apply_static() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 403 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     THIS->apply(*other, true); 
#line 35080 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_apply_dynamic); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_apply_dynamic)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	StaticPrintConfig *	THIS;
	DynamicPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::apply_dynamic() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::apply_dynamic() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 408 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
     THIS->apply(*other, true); 
#line 35123 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_get_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_keys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	std::vector<std::string>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_keys() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 413 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->keys();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35161 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get_extrusion_axis); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_extrusion_axis)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_extrusion_axis() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 427 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
            if (GCodeConfig* config = dynamic_cast<GCodeConfig*>(THIS)) {
                RETVAL = config->get_extrusion_axis();
            } else {
                CONFESS("This StaticConfig object does not provide get_extrusion_axis()");
            }
#line 35211 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_setenv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_setenv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::setenv() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 437 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->setenv_();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35254 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_min_object_distance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_min_object_distance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::min_object_distance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 450 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      RETVAL = THIS->min_object_distance();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35293 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static__load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static__load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	StaticPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::_load() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 464 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->load( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35341 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static__load_from_gcode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static__load_from_gcode)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	StaticPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::_load_from_gcode() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 477 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->load_from_gcode( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35388 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static__save); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static__save)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	StaticPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::_save() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      // const char * c = SvPV(ST(1), len);
      // Always convert strings to UTF-8 before passing them to XS
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 490 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
    try {
      THIS->save( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35435 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_print_config_def); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_print_config_def)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 509 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp"
        t_optiondef_map &def = Slic3r::print_config_def.options;

        HV* options_hv = newHV();
        for (t_optiondef_map::iterator oit = def.begin(); oit != def.end(); ++oit) {
            HV* hv = newHV();

            t_config_option_key opt_key = oit->first;
            ConfigOptionDef* optdef     = &oit->second;

            const char* opt_type;
            if (optdef->type == coFloat || optdef->type == coFloats || optdef->type == coFloatOrPercent) {
                opt_type = "f";
            } else if (optdef->type == coPercent || optdef->type == coPercents) {
                opt_type = "percent";
            } else if (optdef->type == coInt || optdef->type == coInts) {
                opt_type = "i";
            } else if (optdef->type == coString) {
                opt_type = "s";
            } else if (optdef->type == coStrings) {
                opt_type = "s@";
            } else if (optdef->type == coPoint || optdef->type == coPoints) {
                opt_type = "point";
            } else if (optdef->type == coBool || optdef->type == coBools) {
                opt_type = "bool";
            } else if (optdef->type == coEnum) {
                opt_type = "select";
            } else {
                throw "Unknown option type";
            }
            (void)hv_stores( hv, "type",        newSVpv(opt_type, 0) );
            (void)hv_stores( hv, "gui_type",    newSVpvn(optdef->gui_type.c_str(), optdef->gui_type.length()) );
            (void)hv_stores( hv, "gui_flags",   newSVpvn(optdef->gui_flags.c_str(), optdef->gui_flags.length()) );
            (void)hv_stores( hv, "label",       newSVpvn_utf8(optdef->label.c_str(), optdef->label.length(), true) );
            if (!optdef->full_label.empty())
                (void)hv_stores( hv, "full_label",  newSVpvn_utf8(optdef->full_label.c_str(), optdef->full_label.length(), true) );
            (void)hv_stores( hv, "category",    newSVpvn_utf8(optdef->category.c_str(), optdef->category.length(), true) );
            (void)hv_stores( hv, "tooltip",     newSVpvn_utf8(optdef->tooltip.c_str(), optdef->tooltip.length(), true) );
            (void)hv_stores( hv, "sidetext",    newSVpvn_utf8(optdef->sidetext.c_str(), optdef->sidetext.length(), true) );
            (void)hv_stores( hv, "cli",         newSVpvn(optdef->cli.c_str(), optdef->cli.length()) );
            (void)hv_stores( hv, "ratio_over",  newSVpvn(optdef->ratio_over.c_str(), optdef->ratio_over.length()) );
            (void)hv_stores( hv, "multiline",   newSViv(optdef->multiline ? 1 : 0) );
            (void)hv_stores( hv, "full_width",  newSViv(optdef->full_width ? 1 : 0) );
            (void)hv_stores( hv, "readonly",    newSViv(optdef->readonly ? 1 : 0) );
            (void)hv_stores( hv, "height",      newSViv(optdef->height) );
            (void)hv_stores( hv, "width",       newSViv(optdef->width) );
            (void)hv_stores( hv, "min",         newSViv(optdef->min) );
            (void)hv_stores( hv, "max",         newSViv(optdef->max) );

            // aliases
            if (!optdef->aliases.empty()) {
                AV* av = newAV();
                av_fill(av, optdef->aliases.size()-1);
                for (std::vector<t_config_option_key>::iterator it = optdef->aliases.begin(); it != optdef->aliases.end(); ++it)
                    av_store(av, it - optdef->aliases.begin(), newSVpvn(it->c_str(), it->length()));
                (void)hv_stores( hv, "aliases", newRV_noinc((SV*)av) );
            }

            // shortcut
            if (!optdef->shortcut.empty()) {
                AV* av = newAV();
                av_fill(av, optdef->shortcut.size()-1);
                for (std::vector<t_config_option_key>::iterator it = optdef->shortcut.begin(); it != optdef->shortcut.end(); ++it)
                    av_store(av, it - optdef->shortcut.begin(), newSVpvn(it->c_str(), it->length()));
                (void)hv_stores( hv, "shortcut", newRV_noinc((SV*)av) );
            }

            // enum_values
            if (!optdef->enum_values.empty()) {
                AV* av = newAV();
                av_fill(av, optdef->enum_values.size()-1);
                for (std::vector<std::string>::iterator it = optdef->enum_values.begin(); it != optdef->enum_values.end(); ++it)
                    av_store(av, it - optdef->enum_values.begin(), newSVpvn(it->c_str(), it->length()));
                (void)hv_stores( hv, "values", newRV_noinc((SV*)av) );
            }

            // enum_labels
            if (!optdef->enum_labels.empty()) {
                AV* av = newAV();
                av_fill(av, optdef->enum_labels.size()-1);
                for (std::vector<std::string>::iterator it = optdef->enum_labels.begin(); it != optdef->enum_labels.end(); ++it)
                    av_store(av, it - optdef->enum_labels.begin(), newSVpvn_utf8(it->c_str(), it->length(), true));
                (void)hv_stores( hv, "labels", newRV_noinc((SV*)av) );
            }

            if (optdef->default_value != NULL)
                (void)hv_stores( hv, "default", ConfigOption_to_SV(*optdef->default_value, *optdef) );
            (void)hv_store( options_hv, opt_key.c_str(), opt_key.length(), newRV_noinc((SV*)hv), 0 );
        }

        RETVAL = newRV_noinc((SV*)options_hv);
#line 35540 "C:/local/Slic3r/build/xs/XS.cpp"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Config.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "clipper.hpp"
#include "libslic3r/ClipperUtils.hpp"

XS_EUPXS(XS_Slic3r__Geometry__Clipper__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 25 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
    RETVAL = ix;
#line 35570 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "polygons, delta, joinType = ClipperLib::jtMiter, miterLimit = 3");
    {
	Polygons	polygons;
	const float	delta = (const float)SvNV(ST(1))
;
	ClipperLib::JoinType	joinType;
	double	miterLimit;
	Polygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::offset",
	             "polygons")
;

	if (items < 3)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(2))
;
	}

	if (items < 4)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(3))
;
	}
#line 35 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = offset(polygons, delta, joinType, miterLimit);
#line 35620 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset_ex)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "polygons, delta, joinType = ClipperLib::jtMiter, miterLimit = 3");
    {
	Polygons	polygons;
	const float	delta = (const float)SvNV(ST(1))
;
	ClipperLib::JoinType	joinType;
	double	miterLimit;
	ExPolygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::offset_ex",
	             "polygons")
;

	if (items < 3)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(2))
;
	}

	if (items < 4)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(3))
;
	}
#line 46 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = offset_ex(polygons, delta, joinType, miterLimit);
#line 35683 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset2); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset2)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 5)
       croak_xs_usage(cv,  "polygons, delta1, delta2, joinType = ClipperLib::jtMiter, miterLimit = 3");
    {
	Polygons	polygons;
	const float	delta1 = (const float)SvNV(ST(1))
;
	const float	delta2 = (const float)SvNV(ST(2))
;
	ClipperLib::JoinType	joinType;
	double	miterLimit;
	Polygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::offset2",
	             "polygons")
;

	if (items < 4)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(3))
;
	}

	if (items < 5)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(4))
;
	}
#line 58 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = offset2(polygons, delta1, delta2, joinType, miterLimit);
#line 35748 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset2_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset2_ex)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 5)
       croak_xs_usage(cv,  "polygons, delta1, delta2, joinType = ClipperLib::jtMiter, miterLimit = 3");
    {
	Polygons	polygons;
	const float	delta1 = (const float)SvNV(ST(1))
;
	const float	delta2 = (const float)SvNV(ST(2))
;
	ClipperLib::JoinType	joinType;
	double	miterLimit;
	ExPolygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::offset2_ex",
	             "polygons")
;

	if (items < 4)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(3))
;
	}

	if (items < 5)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(4))
;
	}
#line 70 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = offset2_ex(polygons, delta1, delta2, joinType, miterLimit);
#line 35813 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "subject, clip, safety_offset = false");
    {
	Polygons	subject;
	Polygons	clip;
	bool	safety_offset;
	Polygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff",
	             "clip")
;

	if (items < 3)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(2))
;
	}
#line 80 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = diff(subject, clip, safety_offset);
#line 35881 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff_ex)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "subject, clip, safety_offset = false");
    {
	Polygons	subject;
	Polygons	clip;
	bool	safety_offset;
	ExPolygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff_ex",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff_ex",
	             "clip")
;

	if (items < 3)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(2))
;
	}
#line 90 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = diff_ex(subject, clip, safety_offset);
#line 35949 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff_pl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff_pl)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "subject, clip");
    {
	Polylines	subject;
	Polygons	clip;
	Polylines	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff_pl",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff_pl",
	             "clip")
;
#line 99 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = diff_pl(subject, clip);
#line 36009 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "subject, clip, safety_offset = false");
    {
	Polygons	subject;
	Polygons	clip;
	bool	safety_offset;
	Polygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection",
	             "clip")
;

	if (items < 3)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(2))
;
	}
#line 109 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = intersection(subject, clip, safety_offset);
#line 36077 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_ex)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "subject, clip, safety_offset = false");
    {
	Polygons	subject;
	Polygons	clip;
	bool	safety_offset;
	ExPolygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_ex",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_ex",
	             "clip")
;

	if (items < 3)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(2))
;
	}
#line 119 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = intersection_ex(subject, clip, safety_offset);
#line 36145 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_pl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_pl)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "subject, clip");
    {
	Polylines	subject;
	Polygons	clip;
	Polylines	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_pl",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_pl",
	             "clip")
;
#line 128 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = intersection_pl(subject, clip);
#line 36205 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_union); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_union)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "subject, safety_offset = false");
    {
	Polygons	subject;
	bool	safety_offset;
	Polygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::union",
	             "subject")
;

	if (items < 2)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(1))
;
	}
#line 137 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = union_(subject, safety_offset);
#line 36258 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_union_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_union_ex)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "subject, safety_offset = false");
    {
	Polygons	subject;
	bool	safety_offset;
	ExPolygons	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::union_ex",
	             "subject")
;

	if (items < 2)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(1))
;
	}
#line 146 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp"
        RETVAL = union_ex(subject, safety_offset);
#line 36311 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/Clipper.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/BridgeDetector.hpp"

XS_EUPXS(XS_Slic3r__BridgeDetector_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36371 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__BridgeDetector_detect_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_detect_angle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::detect_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
    try {
      RETVAL = THIS->detect_angle();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36410 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_coverage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_coverage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::coverage() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 45 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
    try {
      RETVAL = THIS->coverage();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36449 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_coverage_by_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_coverage_by_angle)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	BridgeDetector *	THIS;
	Polygons	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::coverage_by_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 59 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
    try {
      RETVAL = THIS->coverage( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36503 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_unsupported_edges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_unsupported_edges)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	Polylines	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::unsupported_edges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
    try {
      RETVAL = THIS->unsupported_edges();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36555 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_unsupported_edges_by_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_unsupported_edges_by_angle)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	BridgeDetector *	THIS;
	Polylines	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::unsupported_edges_by_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 87 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
    try {
      RETVAL = THIS->unsupported_edges( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36609 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_angle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 101 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
     RETVAL = THIS->angle; 
#line 36654 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_resolution); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_resolution)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::resolution() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 107 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
     RETVAL = THIS->resolution; 
#line 36686 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_new)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "CLASS, expolygon, lower_slices, extrusion_width");
    {
	ExPolygon*	expolygon;
	ExPolygonCollection*	lower_slices;
	long	extrusion_width = (long)SvIV(ST(3))
;
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	BridgeDetector *	RETVAL;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(expolygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(expolygon) )) {
              expolygon = (ExPolygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("expolygon is not of type %s (got %s)", Slic3r::perl_class_name(expolygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::new() -- expolygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(lower_slices) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(lower_slices) )) {
              lower_slices = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("lower_slices is not of type %s (got %s)", Slic3r::perl_class_name(lower_slices), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::new() -- lower_slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 118 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
        RETVAL = new BridgeDetector(*expolygon, *lower_slices, extrusion_width);
#line 36735 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_new_expolygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_new_expolygons)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, expolygons, lower_slices, extrusion_width");
    {
	ExPolygonCollection*	expolygons;
	ExPolygonCollection*	lower_slices;
	long	extrusion_width = (long)SvIV(ST(3))
;
	BridgeDetector *	THIS;
	BridgeDetector *	RETVAL;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(expolygons) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(expolygons) )) {
              expolygons = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("expolygons is not of type %s (got %s)", Slic3r::perl_class_name(expolygons), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::new_expolygons() -- expolygons is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(lower_slices) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(lower_slices) )) {
              lower_slices = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("lower_slices is not of type %s (got %s)", Slic3r::perl_class_name(lower_slices), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::new_expolygons() -- lower_slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::new_expolygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 128 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp"
        RETVAL = new BridgeDetector(expolygons->expolygons, *lower_slices, extrusion_width);
#line 36803 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BridgeDetector.xsp' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/BoundingBox.hpp"
#include "libslic3r/Point.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	BoundingBox *	RETVAL;
#line 22 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = new BoundingBox();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36849 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36896 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 52 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS; 
#line 36926 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_merge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_merge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bb");
    {
	BoundingBox *	THIS;
	BoundingBox*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::merge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bb) )) {
              bb = (BoundingBox *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::merge() -- bb is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 58 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->merge(*bb); 
#line 36977 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_merge_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_merge_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBox *	THIS;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::merge_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::merge_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 63 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->merge(*point); 
#line 37020 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	BoundingBox *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 68 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37059 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	BoundingBox *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 81 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37100 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_offset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, delta");
    {
	BoundingBox *	THIS;
	double	delta = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 94 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      THIS->offset( delta );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37139 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBox *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 107 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->contains(*point); 
#line 37184 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_overlap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_overlap)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bbox");
    {
	BoundingBox *	THIS;
	bool	RETVAL;
	dXSTARG;
	BoundingBox*	bbox;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::overlap() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bbox) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bbox) )) {
              bbox = (BoundingBox *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bbox is not of type %s (got %s)", Slic3r::perl_class_name(bbox), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::overlap() -- bbox is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 113 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->overlap(*bbox); 
#line 37230 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_polygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_polygon)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::polygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 119 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->polygon();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37269 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 133 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->size();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37315 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_center); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_center)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::center() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 147 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->center();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37361 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::empty() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 161 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = empty(*THIS); 
#line 37400 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_radius); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_radius)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::radius() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 167 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->radius();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37440 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_min_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_min_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::min_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 181 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min; 
#line 37471 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_max_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_max_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::max_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 187 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max; 
#line 37509 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_x_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_x_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::x_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 193 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min.x; 
#line 37548 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_x_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_x_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::x_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 199 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max.x; 
#line 37580 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_y_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_y_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::y_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 205 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min.y; 
#line 37612 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_y_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_y_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::y_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 211 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max.y; 
#line 37644 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_serialize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 217 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     char buf[2048]; sprintf(buf, "%ld,%ld;%ld,%ld", THIS->min.x, THIS->min.y, THIS->max.x, THIS->max.y); RETVAL = buf; 
#line 37675 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_defined); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_defined)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::defined() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 223 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->defined; 
#line 37712 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_new_from_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_new_from_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, points");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	Points	points;
	BoundingBox *	RETVAL;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::BoundingBox::new_from_points",
	             "points")
;
#line 233 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
        RETVAL = new BoundingBox(points);
#line 37746 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	BoundingBoxf *	RETVAL;
#line 248 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = new BoundingBoxf();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37782 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 265 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37829 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<BoundingBoxf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 278 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS; 
#line 37859 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_merge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_merge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bb");
    {
	BoundingBoxf *	THIS;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::merge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bb) )) {
              bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::merge() -- bb is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 284 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->merge(*bb); 
#line 37910 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_merge_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_merge_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBoxf *	THIS;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::merge_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::merge_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 289 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->merge(*point); 
#line 37953 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	BoundingBoxf *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 294 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37992 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	BoundingBoxf *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 307 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38033 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 320 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->size();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38071 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_center); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_center)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::center() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 334 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->center();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38117 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_radius); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_radius)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::radius() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 348 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->radius();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38164 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::empty() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 362 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = empty(*THIS); 
#line 38196 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_min_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_min_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::min_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 368 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min; 
#line 38227 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_max_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_max_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::max_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 374 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max; 
#line 38265 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_x_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_x_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::x_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 380 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min.x; 
#line 38304 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_x_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_x_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::x_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 386 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max.x; 
#line 38336 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_y_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_y_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::y_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 392 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min.y; 
#line 38368 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_y_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_y_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::y_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 398 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max.y; 
#line 38400 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_x_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_x_min)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	BoundingBoxf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::set_x_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 404 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->min.x = val; 
#line 38432 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_x_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_x_max)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	BoundingBoxf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::set_x_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 409 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->max.x = val; 
#line 38463 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_y_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_y_min)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	BoundingBoxf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::set_y_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 414 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->min.y = val; 
#line 38494 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_y_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_y_max)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	BoundingBoxf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::set_y_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 419 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->max.y = val; 
#line 38525 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_serialize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 424 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     char buf[2048]; sprintf(buf, "%lf,%lf;%lf,%lf", THIS->min.x, THIS->min.y, THIS->max.x, THIS->max.y); RETVAL = buf; 
#line 38555 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_defined); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_defined)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::defined() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 430 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->defined; 
#line 38592 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_new_from_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_new_from_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, points");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	Pointfs	points;
	BoundingBoxf *	RETVAL;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::BoundingBoxf::new_from_points",
	             "points")
;
#line 440 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
        RETVAL = new BoundingBoxf(points);
#line 38626 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	BoundingBoxf3 *	RETVAL;
#line 455 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = new BoundingBoxf3();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38662 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 472 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38709 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 485 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS; 
#line 38739 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_merge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_merge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bb");
    {
	BoundingBoxf3 *	THIS;
	BoundingBoxf3*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::merge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bb) )) {
              bb = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::merge() -- bb is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 491 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->merge(*bb); 
#line 38790 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_merge_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_merge_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBoxf3 *	THIS;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::merge_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::merge_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 496 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     THIS->merge(*point); 
#line 38833 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	BoundingBoxf3 *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 501 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38872 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	BoundingBoxf3 *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 514 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38915 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_offset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, delta");
    {
	BoundingBoxf3 *	THIS;
	double	delta = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 527 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      THIS->offset( delta );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38954 "C:/local/Slic3r/build/xs/XS.cpp"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBoxf3 *	THIS;
	bool	RETVAL;
	dXSTARG;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 540 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->contains(*point); 
#line 38999 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 546 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->size();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39038 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_center); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_center)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::center() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 560 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->center();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39084 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_radius); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_radius)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::radius() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 574 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
    try {
      RETVAL = THIS->radius();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39131 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::empty() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 588 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = empty(*THIS); 
#line 39163 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_min_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_min_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::min_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 594 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min; 
#line 39194 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_max_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_max_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::max_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 600 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max; 
#line 39232 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_x_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_x_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::x_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 606 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min.x; 
#line 39271 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_x_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_x_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::x_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 612 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max.x; 
#line 39303 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_y_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_y_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::y_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 618 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min.y; 
#line 39335 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_y_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_y_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::y_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 624 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max.y; 
#line 39367 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_z_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_z_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::z_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 630 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->min.z; 
#line 39399 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_z_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_z_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::z_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 636 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->max.z; 
#line 39431 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_serialize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 642 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     char buf[2048]; sprintf(buf, "%lf,%lf,%lf;%lf,%lf,%lf", THIS->min.x, THIS->min.y, THIS->min.z, THIS->max.x, THIS->max.y, THIS->max.z); RETVAL = buf; 
#line 39462 "C:/local/Slic3r/build/xs/XS.cpp"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_defined); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_defined)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::defined() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 648 "c:\\\\wperl64\\\\bin\\\\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp"
     RETVAL = THIS->defined; 
#line 39499 "C:/local/Slic3r/build/xs/XS.cpp"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from 'c:\wperl64\bin\perl.exe -MExtUtils::XSpp::Cmd -e xspp -- -t C:/local/Slic3r/xs/xsp/typemap.xspt C:/local/Slic3r/xs/xsp/BoundingBox.xsp' */

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Slic3r__XS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Slic3r__XS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Slic3r::VERSION", XS_Slic3r_VERSION);
        newXS_deffile("Slic3r::BUILD", XS_Slic3r_BUILD);
        newXS_deffile("Slic3r::DEBUG_OUT_PATH_PREFIX", XS_Slic3r_DEBUG_OUT_PATH_PREFIX);
        newXS_deffile("Slic3r::FORK_NAME", XS_Slic3r_FORK_NAME);
        newXS_deffile("Slic3r::set_logging_level", XS_Slic3r_set_logging_level);
        newXS_deffile("Slic3r::trace", XS_Slic3r_trace);
        newXS_deffile("Slic3r::encode_path", XS_Slic3r_encode_path);
        newXS_deffile("Slic3r::decode_path", XS_Slic3r_decode_path);
        newXS_deffile("Slic3r::normalize_utf8_nfc", XS_Slic3r_normalize_utf8_nfc);
        newXS_deffile("Slic3r::xspp_test_croak_hangs_on_strawberry", XS_Slic3r_xspp_test_croak_hangs_on_strawberry);
        newXS_deffile("Slic3r::TriangleMesh::new", XS_Slic3r__TriangleMesh_new);
        newXS_deffile("Slic3r::TriangleMesh::DESTROY", XS_Slic3r__TriangleMesh_DESTROY);
        newXS_deffile("Slic3r::TriangleMesh::clone", XS_Slic3r__TriangleMesh_clone);
        newXS_deffile("Slic3r::TriangleMesh::ReadSTLFile", XS_Slic3r__TriangleMesh_ReadSTLFile);
        newXS_deffile("Slic3r::TriangleMesh::write_ascii", XS_Slic3r__TriangleMesh_write_ascii);
        newXS_deffile("Slic3r::TriangleMesh::write_binary", XS_Slic3r__TriangleMesh_write_binary);
        newXS_deffile("Slic3r::TriangleMesh::repair", XS_Slic3r__TriangleMesh_repair);
        newXS_deffile("Slic3r::TriangleMesh::WriteOBJFile", XS_Slic3r__TriangleMesh_WriteOBJFile);
        newXS_deffile("Slic3r::TriangleMesh::scale", XS_Slic3r__TriangleMesh_scale);
        newXS_deffile("Slic3r::TriangleMesh::scale_xyz", XS_Slic3r__TriangleMesh_scale_xyz);
        newXS_deffile("Slic3r::TriangleMesh::translate", XS_Slic3r__TriangleMesh_translate);
        newXS_deffile("Slic3r::TriangleMesh::rotate_x", XS_Slic3r__TriangleMesh_rotate_x);
        newXS_deffile("Slic3r::TriangleMesh::rotate_y", XS_Slic3r__TriangleMesh_rotate_y);
        newXS_deffile("Slic3r::TriangleMesh::rotate_z", XS_Slic3r__TriangleMesh_rotate_z);
        newXS_deffile("Slic3r::TriangleMesh::mirror_x", XS_Slic3r__TriangleMesh_mirror_x);
        newXS_deffile("Slic3r::TriangleMesh::mirror_y", XS_Slic3r__TriangleMesh_mirror_y);
        newXS_deffile("Slic3r::TriangleMesh::mirror_z", XS_Slic3r__TriangleMesh_mirror_z);
        newXS_deffile("Slic3r::TriangleMesh::align_to_origin", XS_Slic3r__TriangleMesh_align_to_origin);
        newXS_deffile("Slic3r::TriangleMesh::rotate", XS_Slic3r__TriangleMesh_rotate);
        newXS_deffile("Slic3r::TriangleMesh::split", XS_Slic3r__TriangleMesh_split);
        newXS_deffile("Slic3r::TriangleMesh::merge", XS_Slic3r__TriangleMesh_merge);
        newXS_deffile("Slic3r::TriangleMesh::horizontal_projection", XS_Slic3r__TriangleMesh_horizontal_projection);
        newXS_deffile("Slic3r::TriangleMesh::convex_hull", XS_Slic3r__TriangleMesh_convex_hull);
        newXS_deffile("Slic3r::TriangleMesh::bounding_box", XS_Slic3r__TriangleMesh_bounding_box);
        newXS_deffile("Slic3r::TriangleMesh::center", XS_Slic3r__TriangleMesh_center);
        newXS_deffile("Slic3r::TriangleMesh::facets_count", XS_Slic3r__TriangleMesh_facets_count);
        newXS_deffile("Slic3r::TriangleMesh::reset_repair_stats", XS_Slic3r__TriangleMesh_reset_repair_stats);
        newXS_deffile("Slic3r::TriangleMesh::ReadFromPerl", XS_Slic3r__TriangleMesh_ReadFromPerl);
        newXS_deffile("Slic3r::TriangleMesh::stats", XS_Slic3r__TriangleMesh_stats);
        newXS_deffile("Slic3r::TriangleMesh::vertices", XS_Slic3r__TriangleMesh_vertices);
        newXS_deffile("Slic3r::TriangleMesh::facets", XS_Slic3r__TriangleMesh_facets);
        newXS_deffile("Slic3r::TriangleMesh::normals", XS_Slic3r__TriangleMesh_normals);
        newXS_deffile("Slic3r::TriangleMesh::size", XS_Slic3r__TriangleMesh_size);
        newXS_deffile("Slic3r::TriangleMesh::slice", XS_Slic3r__TriangleMesh_slice);
        newXS_deffile("Slic3r::TriangleMesh::cut", XS_Slic3r__TriangleMesh_cut);
        newXS_deffile("Slic3r::TriangleMesh::bb3", XS_Slic3r__TriangleMesh_bb3);
        newXS_deffile("Slic3r::TriangleMesh::cube", XS_Slic3r__TriangleMesh_cube);
        newXS_deffile("Slic3r::TriangleMesh::cylinder", XS_Slic3r__TriangleMesh_cylinder);
        newXS_deffile("Slic3r::TriangleMesh::sphere", XS_Slic3r__TriangleMesh_sphere);
        newXS_deffile("Slic3r::TriangleMesh::hello_world", XS_Slic3r__TriangleMesh_hello_world);
        newXS_deffile("Slic3r::Surface::Collection::_new", XS_Slic3r__Surface__Collection__new);
        newXS_deffile("Slic3r::Surface::Collection::DESTROY", XS_Slic3r__Surface__Collection_DESTROY);
        newXS_deffile("Slic3r::Surface::Collection::clear", XS_Slic3r__Surface__Collection_clear);
        newXS_deffile("Slic3r::Surface::Collection::append", XS_Slic3r__Surface__Collection_append);
        newXS_deffile("Slic3r::Surface::Collection::count", XS_Slic3r__Surface__Collection_count);
        newXS_deffile("Slic3r::Surface::Collection::simplify", XS_Slic3r__Surface__Collection_simplify);
        newXS_deffile("Slic3r::Surface::Collection::arrayref", XS_Slic3r__Surface__Collection_arrayref);
        newXS_deffile("Slic3r::Surface::Collection::filter_by_type", XS_Slic3r__Surface__Collection_filter_by_type);
        newXS_deffile("Slic3r::Surface::Collection::replace", XS_Slic3r__Surface__Collection_replace);
        newXS_deffile("Slic3r::Surface::Collection::set_surface_type", XS_Slic3r__Surface__Collection_set_surface_type);
        newXS_deffile("Slic3r::Surface::Collection::group", XS_Slic3r__Surface__Collection_group);
        newXS_deffile("Slic3r::Surface::DESTROY", XS_Slic3r__Surface_DESTROY);
        newXS_deffile("Slic3r::Surface::expolygon", XS_Slic3r__Surface_expolygon);
        newXS_deffile("Slic3r::Surface::thickness", XS_Slic3r__Surface_thickness);
        newXS_deffile("Slic3r::Surface::thickness_layers", XS_Slic3r__Surface_thickness_layers);
        newXS_deffile("Slic3r::Surface::area", XS_Slic3r__Surface_area);
        newXS_deffile("Slic3r::Surface::is_solid", XS_Slic3r__Surface_is_solid);
        newXS_deffile("Slic3r::Surface::is_external", XS_Slic3r__Surface_is_external);
        newXS_deffile("Slic3r::Surface::is_internal", XS_Slic3r__Surface_is_internal);
        newXS_deffile("Slic3r::Surface::is_bottom", XS_Slic3r__Surface_is_bottom);
        newXS_deffile("Slic3r::Surface::is_bridge", XS_Slic3r__Surface_is_bridge);
        newXS_deffile("Slic3r::Surface::_new", XS_Slic3r__Surface__new);
        newXS_deffile("Slic3r::Surface::surface_type", XS_Slic3r__Surface_surface_type);
        newXS_deffile("Slic3r::Surface::bridge_angle", XS_Slic3r__Surface_bridge_angle);
        newXS_deffile("Slic3r::Surface::extra_perimeters", XS_Slic3r__Surface_extra_perimeters);
        newXS_deffile("Slic3r::Surface::polygons", XS_Slic3r__Surface_polygons);
        newXS_deffile("Slic3r::Surface::offset", XS_Slic3r__Surface_offset);
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_BOTTOM", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stBottom;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_BOTTOMBRIDGE", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stBottomBridge;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_INTERNAL", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stInternal;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_INTERNALBRIDGE", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stInternalBridge;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_INTERNALSOLID", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stInternalSolid;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_INTERNALVOID", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stInternalVoid;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_TOP", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stTop;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPW_PERIMETER", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stPerimeter;
        cv = newXSproto_portable("Slic3r::Surface::_constant", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_BRIM", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = psBrim;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_INFILL", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posInfill;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_PERIMETERS", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posPerimeters;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_PREPARE_INFILL", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posPrepareInfill;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_SKIRT", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = psSkirt;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_SLICE", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posSlice;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_SUPPORTMATERIAL", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posSupportMaterial;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_WIPE_TOWER", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = psWipeTower;
        cv = newXSproto_portable("Slic3r::Print::State::_constant", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::Print::Region::config", XS_Slic3r__Print__Region_config);
        newXS_deffile("Slic3r::Print::Region::print", XS_Slic3r__Print__Region_print);
        newXS_deffile("Slic3r::Print::Region::flow", XS_Slic3r__Print__Region_flow);
        newXS_deffile("Slic3r::Print::Object::add_region_volume", XS_Slic3r__Print__Object_add_region_volume);
        newXS_deffile("Slic3r::Print::Object::get_region_volumes", XS_Slic3r__Print__Object_get_region_volumes);
        newXS_deffile("Slic3r::Print::Object::region_count", XS_Slic3r__Print__Object_region_count);
        newXS_deffile("Slic3r::Print::Object::print", XS_Slic3r__Print__Object_print);
        newXS_deffile("Slic3r::Print::Object::model_object", XS_Slic3r__Print__Object_model_object);
        newXS_deffile("Slic3r::Print::Object::config", XS_Slic3r__Print__Object_config);
        newXS_deffile("Slic3r::Print::Object::copies", XS_Slic3r__Print__Object_copies);
        newXS_deffile("Slic3r::Print::Object::layer_height_ranges", XS_Slic3r__Print__Object_layer_height_ranges);
        newXS_deffile("Slic3r::Print::Object::layer_height_profile", XS_Slic3r__Print__Object_layer_height_profile);
        newXS_deffile("Slic3r::Print::Object::size", XS_Slic3r__Print__Object_size);
        newXS_deffile("Slic3r::Print::Object::bounding_box", XS_Slic3r__Print__Object_bounding_box);
        newXS_deffile("Slic3r::Print::Object::_shifted_copies", XS_Slic3r__Print__Object__shifted_copies);
        newXS_deffile("Slic3r::Print::Object::set_shifted_copies", XS_Slic3r__Print__Object_set_shifted_copies);
        newXS_deffile("Slic3r::Print::Object::add_copy", XS_Slic3r__Print__Object_add_copy);
        newXS_deffile("Slic3r::Print::Object::delete_last_copy", XS_Slic3r__Print__Object_delete_last_copy);
        newXS_deffile("Slic3r::Print::Object::delete_all_copies", XS_Slic3r__Print__Object_delete_all_copies);
        newXS_deffile("Slic3r::Print::Object::set_copies", XS_Slic3r__Print__Object_set_copies);
        newXS_deffile("Slic3r::Print::Object::reload_model_instances", XS_Slic3r__Print__Object_reload_model_instances);
        newXS_deffile("Slic3r::Print::Object::set_layer_height_ranges", XS_Slic3r__Print__Object_set_layer_height_ranges);
        newXS_deffile("Slic3r::Print::Object::set_layer_height_profile", XS_Slic3r__Print__Object_set_layer_height_profile);
        newXS_deffile("Slic3r::Print::Object::total_layer_count", XS_Slic3r__Print__Object_total_layer_count);
        newXS_deffile("Slic3r::Print::Object::layer_count", XS_Slic3r__Print__Object_layer_count);
        newXS_deffile("Slic3r::Print::Object::clear_layers", XS_Slic3r__Print__Object_clear_layers);
        newXS_deffile("Slic3r::Print::Object::get_layer", XS_Slic3r__Print__Object_get_layer);
        newXS_deffile("Slic3r::Print::Object::add_layer", XS_Slic3r__Print__Object_add_layer);
        newXS_deffile("Slic3r::Print::Object::support_layer_count", XS_Slic3r__Print__Object_support_layer_count);
        newXS_deffile("Slic3r::Print::Object::clear_support_layers", XS_Slic3r__Print__Object_clear_support_layers);
        newXS_deffile("Slic3r::Print::Object::get_support_layer", XS_Slic3r__Print__Object_get_support_layer);
        newXS_deffile("Slic3r::Print::Object::add_support_layer", XS_Slic3r__Print__Object_add_support_layer);
        newXS_deffile("Slic3r::Print::Object::step_done", XS_Slic3r__Print__Object_step_done);
        newXS_deffile("Slic3r::Print::Object::set_step_done", XS_Slic3r__Print__Object_set_step_done);
        newXS_deffile("Slic3r::Print::Object::set_step_started", XS_Slic3r__Print__Object_set_step_started);
        newXS_deffile("Slic3r::Print::Object::_slice", XS_Slic3r__Print__Object__slice);
        newXS_deffile("Slic3r::Print::Object::_fix_slicing_errors", XS_Slic3r__Print__Object__fix_slicing_errors);
        newXS_deffile("Slic3r::Print::Object::_simplify_slices", XS_Slic3r__Print__Object__simplify_slices);
        newXS_deffile("Slic3r::Print::Object::_prepare_infill", XS_Slic3r__Print__Object__prepare_infill);
        newXS_deffile("Slic3r::Print::Object::detect_surfaces_type", XS_Slic3r__Print__Object_detect_surfaces_type);
        newXS_deffile("Slic3r::Print::Object::process_external_surfaces", XS_Slic3r__Print__Object_process_external_surfaces);
        newXS_deffile("Slic3r::Print::Object::_make_perimeters", XS_Slic3r__Print__Object__make_perimeters);
        newXS_deffile("Slic3r::Print::Object::_infill", XS_Slic3r__Print__Object__infill);
        newXS_deffile("Slic3r::Print::Object::_generate_support_material", XS_Slic3r__Print__Object__generate_support_material);
        newXS_deffile("Slic3r::Print::Object::get_layer_height_min_max", XS_Slic3r__Print__Object_get_layer_height_min_max);
        newXS_deffile("Slic3r::Print::Object::adjust_layer_height_profile", XS_Slic3r__Print__Object_adjust_layer_height_profile);
        newXS_deffile("Slic3r::Print::Object::reset_layer_height_profile", XS_Slic3r__Print__Object_reset_layer_height_profile);
        newXS_deffile("Slic3r::Print::Object::ptr", XS_Slic3r__Print__Object_ptr);
        newXS_deffile("Slic3r::Print::new", XS_Slic3r__Print_new);
        newXS_deffile("Slic3r::Print::DESTROY", XS_Slic3r__Print_DESTROY);
        newXS_deffile("Slic3r::Print::config", XS_Slic3r__Print_config);
        newXS_deffile("Slic3r::Print::default_object_config", XS_Slic3r__Print_default_object_config);
        newXS_deffile("Slic3r::Print::default_region_config", XS_Slic3r__Print_default_region_config);
        newXS_deffile("Slic3r::Print::placeholder_parser", XS_Slic3r__Print_placeholder_parser);
        newXS_deffile("Slic3r::Print::skirt", XS_Slic3r__Print_skirt);
        newXS_deffile("Slic3r::Print::brim", XS_Slic3r__Print_brim);
        newXS_deffile("Slic3r::Print::objects", XS_Slic3r__Print_objects);
        newXS_deffile("Slic3r::Print::clear_objects", XS_Slic3r__Print_clear_objects);
        newXS_deffile("Slic3r::Print::get_object", XS_Slic3r__Print_get_object);
        newXS_deffile("Slic3r::Print::delete_object", XS_Slic3r__Print_delete_object);
        newXS_deffile("Slic3r::Print::reload_object", XS_Slic3r__Print_reload_object);
        newXS_deffile("Slic3r::Print::reload_model_instances", XS_Slic3r__Print_reload_model_instances);
        newXS_deffile("Slic3r::Print::object_count", XS_Slic3r__Print_object_count);
        newXS_deffile("Slic3r::Print::regions", XS_Slic3r__Print_regions);
        newXS_deffile("Slic3r::Print::get_region", XS_Slic3r__Print_get_region);
        newXS_deffile("Slic3r::Print::add_region", XS_Slic3r__Print_add_region);
        newXS_deffile("Slic3r::Print::region_count", XS_Slic3r__Print_region_count);
        newXS_deffile("Slic3r::Print::step_done", XS_Slic3r__Print_step_done);
        newXS_deffile("Slic3r::Print::object_step_done", XS_Slic3r__Print_object_step_done);
        newXS_deffile("Slic3r::Print::set_step_done", XS_Slic3r__Print_set_step_done);
        newXS_deffile("Slic3r::Print::set_step_started", XS_Slic3r__Print_set_step_started);
        newXS_deffile("Slic3r::Print::clear_filament_stats", XS_Slic3r__Print_clear_filament_stats);
        newXS_deffile("Slic3r::Print::set_filament_stats", XS_Slic3r__Print_set_filament_stats);
        newXS_deffile("Slic3r::Print::filament_stats", XS_Slic3r__Print_filament_stats);
        newXS_deffile("Slic3r::Print::_simplify_slices", XS_Slic3r__Print__simplify_slices);
        newXS_deffile("Slic3r::Print::max_allowed_layer_height", XS_Slic3r__Print_max_allowed_layer_height);
        newXS_deffile("Slic3r::Print::has_support_material", XS_Slic3r__Print_has_support_material);
        newXS_deffile("Slic3r::Print::auto_assign_extruders", XS_Slic3r__Print_auto_assign_extruders);
        newXS_deffile("Slic3r::Print::output_filename", XS_Slic3r__Print_output_filename);
        newXS_deffile("Slic3r::Print::output_filepath", XS_Slic3r__Print_output_filepath);
        newXS_deffile("Slic3r::Print::add_model_object", XS_Slic3r__Print_add_model_object);
        newXS_deffile("Slic3r::Print::apply_config", XS_Slic3r__Print_apply_config);
        newXS_deffile("Slic3r::Print::has_infinite_skirt", XS_Slic3r__Print_has_infinite_skirt);
        newXS_deffile("Slic3r::Print::has_skirt", XS_Slic3r__Print_has_skirt);
        newXS_deffile("Slic3r::Print::extruders", XS_Slic3r__Print_extruders);
        newXS_deffile("Slic3r::Print::_validate", XS_Slic3r__Print__validate);
        newXS_deffile("Slic3r::Print::bounding_box", XS_Slic3r__Print_bounding_box);
        newXS_deffile("Slic3r::Print::total_bounding_box", XS_Slic3r__Print_total_bounding_box);
        newXS_deffile("Slic3r::Print::skirt_first_layer_height", XS_Slic3r__Print_skirt_first_layer_height);
        newXS_deffile("Slic3r::Print::brim_flow", XS_Slic3r__Print_brim_flow);
        newXS_deffile("Slic3r::Print::skirt_flow", XS_Slic3r__Print_skirt_flow);
        newXS_deffile("Slic3r::Print::_make_skirt", XS_Slic3r__Print__make_skirt);
        newXS_deffile("Slic3r::Print::_make_brim", XS_Slic3r__Print__make_brim);
        newXS_deffile("Slic3r::Print::has_wipe_tower", XS_Slic3r__Print_has_wipe_tower);
        newXS_deffile("Slic3r::Print::_clear_wipe_tower", XS_Slic3r__Print__clear_wipe_tower);
        newXS_deffile("Slic3r::Print::_make_wipe_tower", XS_Slic3r__Print__make_wipe_tower);
        newXS_deffile("Slic3r::Print::total_used_filament", XS_Slic3r__Print_total_used_filament);
        newXS_deffile("Slic3r::Print::total_extruded_volume", XS_Slic3r__Print_total_extruded_volume);
        newXS_deffile("Slic3r::Print::total_weight", XS_Slic3r__Print_total_weight);
        newXS_deffile("Slic3r::Print::total_cost", XS_Slic3r__Print_total_cost);
        newXS_deffile("Slic3r::Polyline::Collection::DESTROY", XS_Slic3r__Polyline__Collection_DESTROY);
        newXS_deffile("Slic3r::Polyline::Collection::clone", XS_Slic3r__Polyline__Collection_clone);
        newXS_deffile("Slic3r::Polyline::Collection::clear", XS_Slic3r__Polyline__Collection_clear);
        newXS_deffile("Slic3r::Polyline::Collection::chained_path", XS_Slic3r__Polyline__Collection_chained_path);
        newXS_deffile("Slic3r::Polyline::Collection::chained_path_from", XS_Slic3r__Polyline__Collection_chained_path_from);
        newXS_deffile("Slic3r::Polyline::Collection::count", XS_Slic3r__Polyline__Collection_count);
        newXS_deffile("Slic3r::Polyline::Collection::leftmost_point", XS_Slic3r__Polyline__Collection_leftmost_point);
        newXS_deffile("Slic3r::Polyline::Collection::new", XS_Slic3r__Polyline__Collection_new);
        newXS_deffile("Slic3r::Polyline::Collection::arrayref", XS_Slic3r__Polyline__Collection_arrayref);
        newXS_deffile("Slic3r::Polyline::Collection::pp", XS_Slic3r__Polyline__Collection_pp);
        newXS_deffile("Slic3r::Polyline::Collection::append", XS_Slic3r__Polyline__Collection_append);
        newXS_deffile("Slic3r::Polyline::DESTROY", XS_Slic3r__Polyline_DESTROY);
        newXS_deffile("Slic3r::Polyline::clone", XS_Slic3r__Polyline_clone);
        newXS_deffile("Slic3r::Polyline::arrayref", XS_Slic3r__Polyline_arrayref);
        newXS_deffile("Slic3r::Polyline::pp", XS_Slic3r__Polyline_pp);
        newXS_deffile("Slic3r::Polyline::scale", XS_Slic3r__Polyline_scale);
        newXS_deffile("Slic3r::Polyline::translate", XS_Slic3r__Polyline_translate);
        newXS_deffile("Slic3r::Polyline::pop_back", XS_Slic3r__Polyline_pop_back);
        newXS_deffile("Slic3r::Polyline::reverse", XS_Slic3r__Polyline_reverse);
        newXS_deffile("Slic3r::Polyline::lines", XS_Slic3r__Polyline_lines);
        newXS_deffile("Slic3r::Polyline::first_point", XS_Slic3r__Polyline_first_point);
        newXS_deffile("Slic3r::Polyline::last_point", XS_Slic3r__Polyline_last_point);
        newXS_deffile("Slic3r::Polyline::equally_spaced_points", XS_Slic3r__Polyline_equally_spaced_points);
        newXS_deffile("Slic3r::Polyline::length", XS_Slic3r__Polyline_length);
        newXS_deffile("Slic3r::Polyline::is_valid", XS_Slic3r__Polyline_is_valid);
        newXS_deffile("Slic3r::Polyline::clip_end", XS_Slic3r__Polyline_clip_end);
        newXS_deffile("Slic3r::Polyline::clip_start", XS_Slic3r__Polyline_clip_start);
        newXS_deffile("Slic3r::Polyline::extend_end", XS_Slic3r__Polyline_extend_end);
        newXS_deffile("Slic3r::Polyline::extend_start", XS_Slic3r__Polyline_extend_start);
        newXS_deffile("Slic3r::Polyline::simplify", XS_Slic3r__Polyline_simplify);
        newXS_deffile("Slic3r::Polyline::simplify_by_visibility", XS_Slic3r__Polyline_simplify_by_visibility);
        newXS_deffile("Slic3r::Polyline::split_at", XS_Slic3r__Polyline_split_at);
        newXS_deffile("Slic3r::Polyline::is_straight", XS_Slic3r__Polyline_is_straight);
        newXS_deffile("Slic3r::Polyline::bounding_box", XS_Slic3r__Polyline_bounding_box);
        newXS_deffile("Slic3r::Polyline::remove_duplicate_points", XS_Slic3r__Polyline_remove_duplicate_points);
        newXS_deffile("Slic3r::Polyline::wkt", XS_Slic3r__Polyline_wkt);
        newXS_deffile("Slic3r::Polyline::new", XS_Slic3r__Polyline_new);
        newXS_deffile("Slic3r::Polyline::append", XS_Slic3r__Polyline_append);
        newXS_deffile("Slic3r::Polyline::append_polyline", XS_Slic3r__Polyline_append_polyline);
        newXS_deffile("Slic3r::Polyline::rotate", XS_Slic3r__Polyline_rotate);
        newXS_deffile("Slic3r::Polyline::grow", XS_Slic3r__Polyline_grow);
        newXS_deffile("Slic3r::Polygon::DESTROY", XS_Slic3r__Polygon_DESTROY);
        newXS_deffile("Slic3r::Polygon::clone", XS_Slic3r__Polygon_clone);
        newXS_deffile("Slic3r::Polygon::arrayref", XS_Slic3r__Polygon_arrayref);
        newXS_deffile("Slic3r::Polygon::pp", XS_Slic3r__Polygon_pp);
        newXS_deffile("Slic3r::Polygon::scale", XS_Slic3r__Polygon_scale);
        newXS_deffile("Slic3r::Polygon::translate", XS_Slic3r__Polygon_translate);
        newXS_deffile("Slic3r::Polygon::reverse", XS_Slic3r__Polygon_reverse);
        newXS_deffile("Slic3r::Polygon::lines", XS_Slic3r__Polygon_lines);
        newXS_deffile("Slic3r::Polygon::split_at_vertex", XS_Slic3r__Polygon_split_at_vertex);
        newXS_deffile("Slic3r::Polygon::split_at_index", XS_Slic3r__Polygon_split_at_index);
        newXS_deffile("Slic3r::Polygon::split_at_first_point", XS_Slic3r__Polygon_split_at_first_point);
        newXS_deffile("Slic3r::Polygon::equally_spaced_points", XS_Slic3r__Polygon_equally_spaced_points);
        newXS_deffile("Slic3r::Polygon::length", XS_Slic3r__Polygon_length);
        newXS_deffile("Slic3r::Polygon::area", XS_Slic3r__Polygon_area);
        newXS_deffile("Slic3r::Polygon::is_counter_clockwise", XS_Slic3r__Polygon_is_counter_clockwise);
        newXS_deffile("Slic3r::Polygon::is_clockwise", XS_Slic3r__Polygon_is_clockwise);
        newXS_deffile("Slic3r::Polygon::make_counter_clockwise", XS_Slic3r__Polygon_make_counter_clockwise);
        newXS_deffile("Slic3r::Polygon::make_clockwise", XS_Slic3r__Polygon_make_clockwise);
        newXS_deffile("Slic3r::Polygon::is_valid", XS_Slic3r__Polygon_is_valid);
        newXS_deffile("Slic3r::Polygon::first_point", XS_Slic3r__Polygon_first_point);
        newXS_deffile("Slic3r::Polygon::contains_point", XS_Slic3r__Polygon_contains_point);
        newXS_deffile("Slic3r::Polygon::simplify", XS_Slic3r__Polygon_simplify);
        newXS_deffile("Slic3r::Polygon::triangulate_convex", XS_Slic3r__Polygon_triangulate_convex);
        newXS_deffile("Slic3r::Polygon::centroid", XS_Slic3r__Polygon_centroid);
        newXS_deffile("Slic3r::Polygon::bounding_box", XS_Slic3r__Polygon_bounding_box);
        newXS_deffile("Slic3r::Polygon::wkt", XS_Slic3r__Polygon_wkt);
        newXS_deffile("Slic3r::Polygon::concave_points", XS_Slic3r__Polygon_concave_points);
        newXS_deffile("Slic3r::Polygon::convex_points", XS_Slic3r__Polygon_convex_points);
        newXS_deffile("Slic3r::Polygon::point_projection", XS_Slic3r__Polygon_point_projection);
        newXS_deffile("Slic3r::Polygon::intersection", XS_Slic3r__Polygon_intersection);
        newXS_deffile("Slic3r::Polygon::first_intersection", XS_Slic3r__Polygon_first_intersection);
        newXS_deffile("Slic3r::Polygon::new", XS_Slic3r__Polygon_new);
        newXS_deffile("Slic3r::Polygon::rotate", XS_Slic3r__Polygon_rotate);
        newXS_deffile("Slic3r::Point::new", XS_Slic3r__Point_new);
        newXS_deffile("Slic3r::Point::DESTROY", XS_Slic3r__Point_DESTROY);
        newXS_deffile("Slic3r::Point::clone", XS_Slic3r__Point_clone);
        newXS_deffile("Slic3r::Point::scale", XS_Slic3r__Point_scale);
        newXS_deffile("Slic3r::Point::translate", XS_Slic3r__Point_translate);
        newXS_deffile("Slic3r::Point::arrayref", XS_Slic3r__Point_arrayref);
        newXS_deffile("Slic3r::Point::pp", XS_Slic3r__Point_pp);
        newXS_deffile("Slic3r::Point::x", XS_Slic3r__Point_x);
        newXS_deffile("Slic3r::Point::y", XS_Slic3r__Point_y);
        newXS_deffile("Slic3r::Point::set_x", XS_Slic3r__Point_set_x);
        newXS_deffile("Slic3r::Point::set_y", XS_Slic3r__Point_set_y);
        newXS_deffile("Slic3r::Point::nearest_point_index", XS_Slic3r__Point_nearest_point_index);
        newXS_deffile("Slic3r::Point::nearest_point", XS_Slic3r__Point_nearest_point);
        newXS_deffile("Slic3r::Point::distance_to", XS_Slic3r__Point_distance_to);
        newXS_deffile("Slic3r::Point::distance_to_line", XS_Slic3r__Point_distance_to_line);
        newXS_deffile("Slic3r::Point::perp_distance_to_line", XS_Slic3r__Point_perp_distance_to_line);
        newXS_deffile("Slic3r::Point::ccw", XS_Slic3r__Point_ccw);
        newXS_deffile("Slic3r::Point::ccw_angle", XS_Slic3r__Point_ccw_angle);
        newXS_deffile("Slic3r::Point::projection_onto_polygon", XS_Slic3r__Point_projection_onto_polygon);
        newXS_deffile("Slic3r::Point::projection_onto_polyline", XS_Slic3r__Point_projection_onto_polyline);
        newXS_deffile("Slic3r::Point::projection_onto_line", XS_Slic3r__Point_projection_onto_line);
        newXS_deffile("Slic3r::Point::negative", XS_Slic3r__Point_negative);
        newXS_deffile("Slic3r::Point::coincides_with_epsilon", XS_Slic3r__Point_coincides_with_epsilon);
        newXS_deffile("Slic3r::Point::serialize", XS_Slic3r__Point_serialize);
        newXS_deffile("Slic3r::Point::rotate", XS_Slic3r__Point_rotate);
        newXS_deffile("Slic3r::Point::coincides_with", XS_Slic3r__Point_coincides_with);
        newXS_deffile("Slic3r::Point3::new", XS_Slic3r__Point3_new);
        newXS_deffile("Slic3r::Point3::DESTROY", XS_Slic3r__Point3_DESTROY);
        newXS_deffile("Slic3r::Point3::clone", XS_Slic3r__Point3_clone);
        newXS_deffile("Slic3r::Point3::x", XS_Slic3r__Point3_x);
        newXS_deffile("Slic3r::Point3::y", XS_Slic3r__Point3_y);
        newXS_deffile("Slic3r::Point3::z", XS_Slic3r__Point3_z);
        newXS_deffile("Slic3r::Point3::serialize", XS_Slic3r__Point3_serialize);
        newXS_deffile("Slic3r::Pointf::new", XS_Slic3r__Pointf_new);
        newXS_deffile("Slic3r::Pointf::DESTROY", XS_Slic3r__Pointf_DESTROY);
        newXS_deffile("Slic3r::Pointf::clone", XS_Slic3r__Pointf_clone);
        newXS_deffile("Slic3r::Pointf::arrayref", XS_Slic3r__Pointf_arrayref);
        newXS_deffile("Slic3r::Pointf::pp", XS_Slic3r__Pointf_pp);
        newXS_deffile("Slic3r::Pointf::x", XS_Slic3r__Pointf_x);
        newXS_deffile("Slic3r::Pointf::y", XS_Slic3r__Pointf_y);
        newXS_deffile("Slic3r::Pointf::set_x", XS_Slic3r__Pointf_set_x);
        newXS_deffile("Slic3r::Pointf::set_y", XS_Slic3r__Pointf_set_y);
        newXS_deffile("Slic3r::Pointf::translate", XS_Slic3r__Pointf_translate);
        newXS_deffile("Slic3r::Pointf::scale", XS_Slic3r__Pointf_scale);
        newXS_deffile("Slic3r::Pointf::rotate", XS_Slic3r__Pointf_rotate);
        newXS_deffile("Slic3r::Pointf::negative", XS_Slic3r__Pointf_negative);
        newXS_deffile("Slic3r::Pointf::vector_to", XS_Slic3r__Pointf_vector_to);
        newXS_deffile("Slic3r::Pointf::serialize", XS_Slic3r__Pointf_serialize);
        newXS_deffile("Slic3r::Pointf3::new", XS_Slic3r__Pointf3_new);
        newXS_deffile("Slic3r::Pointf3::DESTROY", XS_Slic3r__Pointf3_DESTROY);
        newXS_deffile("Slic3r::Pointf3::clone", XS_Slic3r__Pointf3_clone);
        newXS_deffile("Slic3r::Pointf3::x", XS_Slic3r__Pointf3_x);
        newXS_deffile("Slic3r::Pointf3::y", XS_Slic3r__Pointf3_y);
        newXS_deffile("Slic3r::Pointf3::z", XS_Slic3r__Pointf3_z);
        newXS_deffile("Slic3r::Pointf3::set_x", XS_Slic3r__Pointf3_set_x);
        newXS_deffile("Slic3r::Pointf3::set_y", XS_Slic3r__Pointf3_set_y);
        newXS_deffile("Slic3r::Pointf3::set_z", XS_Slic3r__Pointf3_set_z);
        newXS_deffile("Slic3r::Pointf3::translate", XS_Slic3r__Pointf3_translate);
        newXS_deffile("Slic3r::Pointf3::scale", XS_Slic3r__Pointf3_scale);
        newXS_deffile("Slic3r::Pointf3::distance_to", XS_Slic3r__Pointf3_distance_to);
        newXS_deffile("Slic3r::Pointf3::negative", XS_Slic3r__Pointf3_negative);
        newXS_deffile("Slic3r::Pointf3::vector_to", XS_Slic3r__Pointf3_vector_to);
        newXS_deffile("Slic3r::Pointf3::serialize", XS_Slic3r__Pointf3_serialize);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::new", XS_Slic3r__GCode__PlaceholderParser_new);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::DESTROY", XS_Slic3r__GCode__PlaceholderParser_DESTROY);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::clone", XS_Slic3r__GCode__PlaceholderParser_clone);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::update_timestamp", XS_Slic3r__GCode__PlaceholderParser_update_timestamp);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::apply_env_variables", XS_Slic3r__GCode__PlaceholderParser_apply_env_variables);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::apply_config", XS_Slic3r__GCode__PlaceholderParser_apply_config);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::set", XS_Slic3r__GCode__PlaceholderParser_set);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::set_multiple", XS_Slic3r__GCode__PlaceholderParser_set_multiple);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::process", XS_Slic3r__GCode__PlaceholderParser_process);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::new", XS_Slic3r__Layer__PerimeterGenerator_new);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::DESTROY", XS_Slic3r__Layer__PerimeterGenerator_DESTROY);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_lower_slices", XS_Slic3r__Layer__PerimeterGenerator_set_lower_slices);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_layer_id", XS_Slic3r__Layer__PerimeterGenerator_set_layer_id);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_perimeter_flow", XS_Slic3r__Layer__PerimeterGenerator_set_perimeter_flow);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_ext_perimeter_flow", XS_Slic3r__Layer__PerimeterGenerator_set_ext_perimeter_flow);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_overhang_flow", XS_Slic3r__Layer__PerimeterGenerator_set_overhang_flow);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_solid_infill_flow", XS_Slic3r__Layer__PerimeterGenerator_set_solid_infill_flow);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::config", XS_Slic3r__Layer__PerimeterGenerator_config);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::process", XS_Slic3r__Layer__PerimeterGenerator_process);
        newXS_deffile("Slic3r::MotionPlanner::new", XS_Slic3r__MotionPlanner_new);
        newXS_deffile("Slic3r::MotionPlanner::DESTROY", XS_Slic3r__MotionPlanner_DESTROY);
        newXS_deffile("Slic3r::MotionPlanner::islands_count", XS_Slic3r__MotionPlanner_islands_count);
        newXS_deffile("Slic3r::MotionPlanner::shortest_path", XS_Slic3r__MotionPlanner_shortest_path);
        newXS_deffile("Slic3r::Model::new", XS_Slic3r__Model_new);
        newXS_deffile("Slic3r::Model::DESTROY", XS_Slic3r__Model_DESTROY);
        newXS_deffile("Slic3r::Model::read_from_file", XS_Slic3r__Model_read_from_file);
        newXS_deffile("Slic3r::Model::clone", XS_Slic3r__Model_clone);
        newXS_deffile("Slic3r::Model::_add_object", XS_Slic3r__Model__add_object);
        newXS_deffile("Slic3r::Model::_add_object_clone", XS_Slic3r__Model__add_object_clone);
        newXS_deffile("Slic3r::Model::delete_object", XS_Slic3r__Model_delete_object);
        newXS_deffile("Slic3r::Model::clear_objects", XS_Slic3r__Model_clear_objects);
        newXS_deffile("Slic3r::Model::objects_count", XS_Slic3r__Model_objects_count);
        newXS_deffile("Slic3r::Model::get_object", XS_Slic3r__Model_get_object);
        newXS_deffile("Slic3r::Model::get_material", XS_Slic3r__Model_get_material);
        newXS_deffile("Slic3r::Model::add_material", XS_Slic3r__Model_add_material);
        newXS_deffile("Slic3r::Model::add_material_clone", XS_Slic3r__Model_add_material_clone);
        newXS_deffile("Slic3r::Model::has_material", XS_Slic3r__Model_has_material);
        newXS_deffile("Slic3r::Model::delete_material", XS_Slic3r__Model_delete_material);
        newXS_deffile("Slic3r::Model::clear_materials", XS_Slic3r__Model_clear_materials);
        newXS_deffile("Slic3r::Model::material_names", XS_Slic3r__Model_material_names);
        newXS_deffile("Slic3r::Model::material_count", XS_Slic3r__Model_material_count);
        newXS_deffile("Slic3r::Model::add_default_instances", XS_Slic3r__Model_add_default_instances);
        newXS_deffile("Slic3r::Model::bounding_box", XS_Slic3r__Model_bounding_box);
        newXS_deffile("Slic3r::Model::center_instances_around_point", XS_Slic3r__Model_center_instances_around_point);
        newXS_deffile("Slic3r::Model::translate", XS_Slic3r__Model_translate);
        newXS_deffile("Slic3r::Model::mesh", XS_Slic3r__Model_mesh);
        newXS_deffile("Slic3r::Model::objects", XS_Slic3r__Model_objects);
        newXS_deffile("Slic3r::Model::arrange_objects", XS_Slic3r__Model_arrange_objects);
        newXS_deffile("Slic3r::Model::duplicate", XS_Slic3r__Model_duplicate);
        newXS_deffile("Slic3r::Model::duplicate_objects", XS_Slic3r__Model_duplicate_objects);
        newXS_deffile("Slic3r::Model::duplicate_objects_grid", XS_Slic3r__Model_duplicate_objects_grid);
        newXS_deffile("Slic3r::Model::looks_like_multipart_object", XS_Slic3r__Model_looks_like_multipart_object);
        newXS_deffile("Slic3r::Model::convert_multipart_object", XS_Slic3r__Model_convert_multipart_object);
        newXS_deffile("Slic3r::Model::print_info", XS_Slic3r__Model_print_info);
        newXS_deffile("Slic3r::Model::store_stl", XS_Slic3r__Model_store_stl);
        newXS_deffile("Slic3r::Model::store_amf", XS_Slic3r__Model_store_amf);
        newXS_deffile("Slic3r::Model::load_stl", XS_Slic3r__Model_load_stl);
        newXS_deffile("Slic3r::Model::load_obj", XS_Slic3r__Model_load_obj);
        newXS_deffile("Slic3r::Model::load_amf", XS_Slic3r__Model_load_amf);
        newXS_deffile("Slic3r::Model::load_prus", XS_Slic3r__Model_load_prus);
        newXS_deffile("Slic3r::Model::Material::model", XS_Slic3r__Model__Material_model);
        newXS_deffile("Slic3r::Model::Material::config", XS_Slic3r__Model__Material_config);
        newXS_deffile("Slic3r::Model::Material::get_attribute", XS_Slic3r__Model__Material_get_attribute);
        newXS_deffile("Slic3r::Model::Material::set_attribute", XS_Slic3r__Model__Material_set_attribute);
        newXS_deffile("Slic3r::Model::Material::attributes", XS_Slic3r__Model__Material_attributes);
        newXS_deffile("Slic3r::Model::Object::volumes", XS_Slic3r__Model__Object_volumes);
        newXS_deffile("Slic3r::Model::Object::instances", XS_Slic3r__Model__Object_instances);
        newXS_deffile("Slic3r::Model::Object::invalidate_bounding_box", XS_Slic3r__Model__Object_invalidate_bounding_box);
        newXS_deffile("Slic3r::Model::Object::mesh", XS_Slic3r__Model__Object_mesh);
        newXS_deffile("Slic3r::Model::Object::raw_mesh", XS_Slic3r__Model__Object_raw_mesh);
        newXS_deffile("Slic3r::Model::Object::instance_bounding_box", XS_Slic3r__Model__Object_instance_bounding_box);
        newXS_deffile("Slic3r::Model::Object::bounding_box", XS_Slic3r__Model__Object_bounding_box);
        newXS_deffile("Slic3r::Model::Object::_add_volume", XS_Slic3r__Model__Object__add_volume);
        newXS_deffile("Slic3r::Model::Object::_add_volume_clone", XS_Slic3r__Model__Object__add_volume_clone);
        newXS_deffile("Slic3r::Model::Object::delete_volume", XS_Slic3r__Model__Object_delete_volume);
        newXS_deffile("Slic3r::Model::Object::clear_volumes", XS_Slic3r__Model__Object_clear_volumes);
        newXS_deffile("Slic3r::Model::Object::volumes_count", XS_Slic3r__Model__Object_volumes_count);
        newXS_deffile("Slic3r::Model::Object::get_volume", XS_Slic3r__Model__Object_get_volume);
        newXS_deffile("Slic3r::Model::Object::move_volume_up", XS_Slic3r__Model__Object_move_volume_up);
        newXS_deffile("Slic3r::Model::Object::move_volume_down", XS_Slic3r__Model__Object_move_volume_down);
        newXS_deffile("Slic3r::Model::Object::_add_instance", XS_Slic3r__Model__Object__add_instance);
        newXS_deffile("Slic3r::Model::Object::_add_instance_clone", XS_Slic3r__Model__Object__add_instance_clone);
        newXS_deffile("Slic3r::Model::Object::delete_last_instance", XS_Slic3r__Model__Object_delete_last_instance);
        newXS_deffile("Slic3r::Model::Object::clear_instances", XS_Slic3r__Model__Object_clear_instances);
        newXS_deffile("Slic3r::Model::Object::instances_count", XS_Slic3r__Model__Object_instances_count);
        newXS_deffile("Slic3r::Model::Object::name", XS_Slic3r__Model__Object_name);
        newXS_deffile("Slic3r::Model::Object::set_name", XS_Slic3r__Model__Object_set_name);
        newXS_deffile("Slic3r::Model::Object::input_file", XS_Slic3r__Model__Object_input_file);
        newXS_deffile("Slic3r::Model::Object::set_input_file", XS_Slic3r__Model__Object_set_input_file);
        newXS_deffile("Slic3r::Model::Object::config", XS_Slic3r__Model__Object_config);
        newXS_deffile("Slic3r::Model::Object::model", XS_Slic3r__Model__Object_model);
        newXS_deffile("Slic3r::Model::Object::layer_height_ranges", XS_Slic3r__Model__Object_layer_height_ranges);
        newXS_deffile("Slic3r::Model::Object::set_layer_height_ranges", XS_Slic3r__Model__Object_set_layer_height_ranges);
        newXS_deffile("Slic3r::Model::Object::layer_height_profile", XS_Slic3r__Model__Object_layer_height_profile);
        newXS_deffile("Slic3r::Model::Object::set_layer_height_profile", XS_Slic3r__Model__Object_set_layer_height_profile);
        newXS_deffile("Slic3r::Model::Object::origin_translation", XS_Slic3r__Model__Object_origin_translation);
        newXS_deffile("Slic3r::Model::Object::set_origin_translation", XS_Slic3r__Model__Object_set_origin_translation);
        newXS_deffile("Slic3r::Model::Object::needed_repair", XS_Slic3r__Model__Object_needed_repair);
        newXS_deffile("Slic3r::Model::Object::materials_count", XS_Slic3r__Model__Object_materials_count);
        newXS_deffile("Slic3r::Model::Object::facets_count", XS_Slic3r__Model__Object_facets_count);
        newXS_deffile("Slic3r::Model::Object::center_around_origin", XS_Slic3r__Model__Object_center_around_origin);
        newXS_deffile("Slic3r::Model::Object::translate", XS_Slic3r__Model__Object_translate);
        newXS_deffile("Slic3r::Model::Object::scale_xyz", XS_Slic3r__Model__Object_scale_xyz);
        newXS_deffile("Slic3r::Model::Object::rotate", XS_Slic3r__Model__Object_rotate);
        newXS_deffile("Slic3r::Model::Object::mirror", XS_Slic3r__Model__Object_mirror);
        newXS_deffile("Slic3r::Model::Object::cut", XS_Slic3r__Model__Object_cut);
        newXS_deffile("Slic3r::Model::Object::split_object", XS_Slic3r__Model__Object_split_object);
        newXS_deffile("Slic3r::Model::Object::print_info", XS_Slic3r__Model__Object_print_info);
        newXS_deffile("Slic3r::Model::Volume::object", XS_Slic3r__Model__Volume_object);
        newXS_deffile("Slic3r::Model::Volume::name", XS_Slic3r__Model__Volume_name);
        newXS_deffile("Slic3r::Model::Volume::set_name", XS_Slic3r__Model__Volume_set_name);
        newXS_deffile("Slic3r::Model::Volume::material_id", XS_Slic3r__Model__Volume_material_id);
        newXS_deffile("Slic3r::Model::Volume::set_material_id", XS_Slic3r__Model__Volume_set_material_id);
        newXS_deffile("Slic3r::Model::Volume::material", XS_Slic3r__Model__Volume_material);
        newXS_deffile("Slic3r::Model::Volume::config", XS_Slic3r__Model__Volume_config);
        newXS_deffile("Slic3r::Model::Volume::mesh", XS_Slic3r__Model__Volume_mesh);
        newXS_deffile("Slic3r::Model::Volume::modifier", XS_Slic3r__Model__Volume_modifier);
        newXS_deffile("Slic3r::Model::Volume::set_modifier", XS_Slic3r__Model__Volume_set_modifier);
        newXS_deffile("Slic3r::Model::Volume::split", XS_Slic3r__Model__Volume_split);
        newXS_deffile("Slic3r::Model::Volume::assign_unique_material", XS_Slic3r__Model__Volume_assign_unique_material);
        newXS_deffile("Slic3r::Model::Instance::object", XS_Slic3r__Model__Instance_object);
        newXS_deffile("Slic3r::Model::Instance::rotation", XS_Slic3r__Model__Instance_rotation);
        newXS_deffile("Slic3r::Model::Instance::scaling_factor", XS_Slic3r__Model__Instance_scaling_factor);
        newXS_deffile("Slic3r::Model::Instance::offset", XS_Slic3r__Model__Instance_offset);
        newXS_deffile("Slic3r::Model::Instance::set_rotation", XS_Slic3r__Model__Instance_set_rotation);
        newXS_deffile("Slic3r::Model::Instance::set_scaling_factor", XS_Slic3r__Model__Instance_set_scaling_factor);
        newXS_deffile("Slic3r::Model::Instance::set_offset", XS_Slic3r__Model__Instance_set_offset);
        newXS_deffile("Slic3r::Model::Instance::transform_mesh", XS_Slic3r__Model__Instance_transform_mesh);
        newXS_deffile("Slic3r::Model::Instance::transform_polygon", XS_Slic3r__Model__Instance_transform_polygon);
        newXS_deffile("Slic3r::Line::DESTROY", XS_Slic3r__Line_DESTROY);
        newXS_deffile("Slic3r::Line::clone", XS_Slic3r__Line_clone);
        newXS_deffile("Slic3r::Line::arrayref", XS_Slic3r__Line_arrayref);
        newXS_deffile("Slic3r::Line::pp", XS_Slic3r__Line_pp);
        newXS_deffile("Slic3r::Line::a", XS_Slic3r__Line_a);
        newXS_deffile("Slic3r::Line::b", XS_Slic3r__Line_b);
        newXS_deffile("Slic3r::Line::reverse", XS_Slic3r__Line_reverse);
        newXS_deffile("Slic3r::Line::scale", XS_Slic3r__Line_scale);
        newXS_deffile("Slic3r::Line::translate", XS_Slic3r__Line_translate);
        newXS_deffile("Slic3r::Line::length", XS_Slic3r__Line_length);
        newXS_deffile("Slic3r::Line::atan2_", XS_Slic3r__Line_atan2_);
        newXS_deffile("Slic3r::Line::orientation", XS_Slic3r__Line_orientation);
        newXS_deffile("Slic3r::Line::direction", XS_Slic3r__Line_direction);
        newXS_deffile("Slic3r::Line::parallel_to", XS_Slic3r__Line_parallel_to);
        newXS_deffile("Slic3r::Line::parallel_to_line", XS_Slic3r__Line_parallel_to_line);
        newXS_deffile("Slic3r::Line::midpoint", XS_Slic3r__Line_midpoint);
        newXS_deffile("Slic3r::Line::point_at", XS_Slic3r__Line_point_at);
        newXS_deffile("Slic3r::Line::intersection_infinite", XS_Slic3r__Line_intersection_infinite);
        newXS_deffile("Slic3r::Line::as_polyline", XS_Slic3r__Line_as_polyline);
        newXS_deffile("Slic3r::Line::normal", XS_Slic3r__Line_normal);
        newXS_deffile("Slic3r::Line::vector", XS_Slic3r__Line_vector);
        newXS_deffile("Slic3r::Line::ccw", XS_Slic3r__Line_ccw);
        newXS_deffile("Slic3r::Line::new", XS_Slic3r__Line_new);
        newXS_deffile("Slic3r::Line::rotate", XS_Slic3r__Line_rotate);
        newXS_deffile("Slic3r::Line::coincides_with", XS_Slic3r__Line_coincides_with);
        newXS_deffile("Slic3r::Linef3::new", XS_Slic3r__Linef3_new);
        newXS_deffile("Slic3r::Linef3::DESTROY", XS_Slic3r__Linef3_DESTROY);
        newXS_deffile("Slic3r::Linef3::clone", XS_Slic3r__Linef3_clone);
        newXS_deffile("Slic3r::Linef3::a", XS_Slic3r__Linef3_a);
        newXS_deffile("Slic3r::Linef3::b", XS_Slic3r__Linef3_b);
        newXS_deffile("Slic3r::Linef3::intersect_plane", XS_Slic3r__Linef3_intersect_plane);
        newXS_deffile("Slic3r::Linef3::scale", XS_Slic3r__Linef3_scale);
        newXS_deffile("Slic3r::Layer::Region::layer", XS_Slic3r__Layer__Region_layer);
        newXS_deffile("Slic3r::Layer::Region::region", XS_Slic3r__Layer__Region_region);
        newXS_deffile("Slic3r::Layer::Region::slices", XS_Slic3r__Layer__Region_slices);
        newXS_deffile("Slic3r::Layer::Region::thin_fills", XS_Slic3r__Layer__Region_thin_fills);
        newXS_deffile("Slic3r::Layer::Region::fill_surfaces", XS_Slic3r__Layer__Region_fill_surfaces);
        newXS_deffile("Slic3r::Layer::Region::perimeter_surfaces", XS_Slic3r__Layer__Region_perimeter_surfaces);
        newXS_deffile("Slic3r::Layer::Region::bridged", XS_Slic3r__Layer__Region_bridged);
        newXS_deffile("Slic3r::Layer::Region::unsupported_bridge_edges", XS_Slic3r__Layer__Region_unsupported_bridge_edges);
        newXS_deffile("Slic3r::Layer::Region::perimeters", XS_Slic3r__Layer__Region_perimeters);
        newXS_deffile("Slic3r::Layer::Region::fills", XS_Slic3r__Layer__Region_fills);
        newXS_deffile("Slic3r::Layer::Region::flow", XS_Slic3r__Layer__Region_flow);
        newXS_deffile("Slic3r::Layer::Region::prepare_fill_surfaces", XS_Slic3r__Layer__Region_prepare_fill_surfaces);
        newXS_deffile("Slic3r::Layer::Region::make_perimeters", XS_Slic3r__Layer__Region_make_perimeters);
        newXS_deffile("Slic3r::Layer::Region::infill_area_threshold", XS_Slic3r__Layer__Region_infill_area_threshold);
        newXS_deffile("Slic3r::Layer::Region::export_region_slices_to_svg", XS_Slic3r__Layer__Region_export_region_slices_to_svg);
        newXS_deffile("Slic3r::Layer::Region::export_region_fill_surfaces_to_svg", XS_Slic3r__Layer__Region_export_region_fill_surfaces_to_svg);
        newXS_deffile("Slic3r::Layer::Region::export_region_slices_to_svg_debug", XS_Slic3r__Layer__Region_export_region_slices_to_svg_debug);
        newXS_deffile("Slic3r::Layer::Region::export_region_fill_surfaces_to_svg_debug", XS_Slic3r__Layer__Region_export_region_fill_surfaces_to_svg_debug);
        newXS_deffile("Slic3r::Layer::as_layer", XS_Slic3r__Layer_as_layer);
        newXS_deffile("Slic3r::Layer::id", XS_Slic3r__Layer_id);
        newXS_deffile("Slic3r::Layer::set_id", XS_Slic3r__Layer_set_id);
        newXS_deffile("Slic3r::Layer::object", XS_Slic3r__Layer_object);
        newXS_deffile("Slic3r::Layer::upper_layer", XS_Slic3r__Layer_upper_layer);
        newXS_deffile("Slic3r::Layer::lower_layer", XS_Slic3r__Layer_lower_layer);
        newXS_deffile("Slic3r::Layer::slicing_errors", XS_Slic3r__Layer_slicing_errors);
        newXS_deffile("Slic3r::Layer::slice_z", XS_Slic3r__Layer_slice_z);
        newXS_deffile("Slic3r::Layer::print_z", XS_Slic3r__Layer_print_z);
        newXS_deffile("Slic3r::Layer::height", XS_Slic3r__Layer_height);
        newXS_deffile("Slic3r::Layer::set_upper_layer", XS_Slic3r__Layer_set_upper_layer);
        newXS_deffile("Slic3r::Layer::set_lower_layer", XS_Slic3r__Layer_set_lower_layer);
        newXS_deffile("Slic3r::Layer::has_upper_layer", XS_Slic3r__Layer_has_upper_layer);
        newXS_deffile("Slic3r::Layer::has_lower_layer", XS_Slic3r__Layer_has_lower_layer);
        newXS_deffile("Slic3r::Layer::region_count", XS_Slic3r__Layer_region_count);
        newXS_deffile("Slic3r::Layer::get_region", XS_Slic3r__Layer_get_region);
        newXS_deffile("Slic3r::Layer::add_region", XS_Slic3r__Layer_add_region);
        newXS_deffile("Slic3r::Layer::slices", XS_Slic3r__Layer_slices);
        newXS_deffile("Slic3r::Layer::ptr", XS_Slic3r__Layer_ptr);
        newXS_deffile("Slic3r::Layer::as_support_layer", XS_Slic3r__Layer_as_support_layer);
        newXS_deffile("Slic3r::Layer::make_slices", XS_Slic3r__Layer_make_slices);
        newXS_deffile("Slic3r::Layer::merge_slices", XS_Slic3r__Layer_merge_slices);
        newXS_deffile("Slic3r::Layer::make_perimeters", XS_Slic3r__Layer_make_perimeters);
        newXS_deffile("Slic3r::Layer::make_fills", XS_Slic3r__Layer_make_fills);
        newXS_deffile("Slic3r::Layer::export_region_slices_to_svg", XS_Slic3r__Layer_export_region_slices_to_svg);
        newXS_deffile("Slic3r::Layer::export_region_fill_surfaces_to_svg", XS_Slic3r__Layer_export_region_fill_surfaces_to_svg);
        newXS_deffile("Slic3r::Layer::export_region_slices_to_svg_debug", XS_Slic3r__Layer_export_region_slices_to_svg_debug);
        newXS_deffile("Slic3r::Layer::export_region_fill_surfaces_to_svg_debug", XS_Slic3r__Layer_export_region_fill_surfaces_to_svg_debug);
        newXS_deffile("Slic3r::Layer::Support::as_layer", XS_Slic3r__Layer__Support_as_layer);
        newXS_deffile("Slic3r::Layer::Support::support_islands", XS_Slic3r__Layer__Support_support_islands);
        newXS_deffile("Slic3r::Layer::Support::support_fills", XS_Slic3r__Layer__Support_support_fills);
        newXS_deffile("Slic3r::Layer::Support::id", XS_Slic3r__Layer__Support_id);
        newXS_deffile("Slic3r::Layer::Support::set_id", XS_Slic3r__Layer__Support_set_id);
        newXS_deffile("Slic3r::Layer::Support::object", XS_Slic3r__Layer__Support_object);
        newXS_deffile("Slic3r::Layer::Support::upper_layer", XS_Slic3r__Layer__Support_upper_layer);
        newXS_deffile("Slic3r::Layer::Support::lower_layer", XS_Slic3r__Layer__Support_lower_layer);
        newXS_deffile("Slic3r::Layer::Support::slicing_errors", XS_Slic3r__Layer__Support_slicing_errors);
        newXS_deffile("Slic3r::Layer::Support::slice_z", XS_Slic3r__Layer__Support_slice_z);
        newXS_deffile("Slic3r::Layer::Support::print_z", XS_Slic3r__Layer__Support_print_z);
        newXS_deffile("Slic3r::Layer::Support::height", XS_Slic3r__Layer__Support_height);
        newXS_deffile("Slic3r::Layer::Support::set_upper_layer", XS_Slic3r__Layer__Support_set_upper_layer);
        newXS_deffile("Slic3r::Layer::Support::set_lower_layer", XS_Slic3r__Layer__Support_set_lower_layer);
        newXS_deffile("Slic3r::Layer::Support::has_upper_layer", XS_Slic3r__Layer__Support_has_upper_layer);
        newXS_deffile("Slic3r::Layer::Support::has_lower_layer", XS_Slic3r__Layer__Support_has_lower_layer);
        newXS_deffile("Slic3r::Layer::Support::region_count", XS_Slic3r__Layer__Support_region_count);
        newXS_deffile("Slic3r::Layer::Support::get_region", XS_Slic3r__Layer__Support_get_region);
        newXS_deffile("Slic3r::Layer::Support::add_region", XS_Slic3r__Layer__Support_add_region);
        newXS_deffile("Slic3r::Layer::Support::slices", XS_Slic3r__Layer__Support_slices);
        newXS_deffile("Slic3r::Layer::Support::export_region_slices_to_svg", XS_Slic3r__Layer__Support_export_region_slices_to_svg);
        newXS_deffile("Slic3r::Layer::Support::export_region_fill_surfaces_to_svg", XS_Slic3r__Layer__Support_export_region_fill_surfaces_to_svg);
        newXS_deffile("Slic3r::Layer::Support::export_region_slices_to_svg_debug", XS_Slic3r__Layer__Support_export_region_slices_to_svg_debug);
        newXS_deffile("Slic3r::Layer::Support::export_region_fill_surfaces_to_svg_debug", XS_Slic3r__Layer__Support_export_region_fill_surfaces_to_svg_debug);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::new", XS_Slic3r__GUI___3DScene__GLShader_new);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::DESTROY", XS_Slic3r__GUI___3DScene__GLShader_DESTROY);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::load", XS_Slic3r__GUI___3DScene__GLShader_load);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::release", XS_Slic3r__GUI___3DScene__GLShader_release);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::get_attrib_location", XS_Slic3r__GUI___3DScene__GLShader_get_attrib_location);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::get_uniform_location", XS_Slic3r__GUI___3DScene__GLShader_get_uniform_location);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::set_uniform", XS_Slic3r__GUI___3DScene__GLShader_set_uniform);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::enable", XS_Slic3r__GUI___3DScene__GLShader_enable);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::disable", XS_Slic3r__GUI___3DScene__GLShader_disable);
        newXS_deffile("Slic3r::GUI::_3DScene::GLShader::last_error", XS_Slic3r__GUI___3DScene__GLShader_last_error);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::new", XS_Slic3r__GUI___3DScene__GLVolume_new);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::DESTROY", XS_Slic3r__GUI___3DScene__GLVolume_DESTROY);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::color", XS_Slic3r__GUI___3DScene__GLVolume_color);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::select_group_id", XS_Slic3r__GUI___3DScene__GLVolume_select_group_id);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::drag_group_id", XS_Slic3r__GUI___3DScene__GLVolume_drag_group_id);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::selected", XS_Slic3r__GUI___3DScene__GLVolume_selected);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::set_selected", XS_Slic3r__GUI___3DScene__GLVolume_set_selected);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::hover", XS_Slic3r__GUI___3DScene__GLVolume_hover);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::set_hover", XS_Slic3r__GUI___3DScene__GLVolume_set_hover);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::object_idx", XS_Slic3r__GUI___3DScene__GLVolume_object_idx);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::volume_idx", XS_Slic3r__GUI___3DScene__GLVolume_volume_idx);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::instance_idx", XS_Slic3r__GUI___3DScene__GLVolume_instance_idx);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::origin", XS_Slic3r__GUI___3DScene__GLVolume_origin);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::translate", XS_Slic3r__GUI___3DScene__GLVolume_translate);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::bounding_box", XS_Slic3r__GUI___3DScene__GLVolume_bounding_box);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::transformed_bounding_box", XS_Slic3r__GUI___3DScene__GLVolume_transformed_bounding_box);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::empty", XS_Slic3r__GUI___3DScene__GLVolume_empty);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::indexed", XS_Slic3r__GUI___3DScene__GLVolume_indexed);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::render", XS_Slic3r__GUI___3DScene__GLVolume_render);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::has_layer_height_texture", XS_Slic3r__GUI___3DScene__GLVolume_has_layer_height_texture);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_width", XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_width);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_height", XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_height);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_cells", XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_cells);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_data_ptr_level0", XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_data_ptr_level0);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_data_ptr_level1", XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_data_ptr_level1);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::layer_height_texture_z_to_row_id", XS_Slic3r__GUI___3DScene__GLVolume_layer_height_texture_z_to_row_id);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::generate_layer_height_texture", XS_Slic3r__GUI___3DScene__GLVolume_generate_layer_height_texture);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::new", XS_Slic3r__GUI___3DScene__GLVolume__Collection_new);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::DESTROY", XS_Slic3r__GUI___3DScene__GLVolume__Collection_DESTROY);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::load_object", XS_Slic3r__GUI___3DScene__GLVolume__Collection_load_object);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::load_wipe_tower_preview", XS_Slic3r__GUI___3DScene__GLVolume__Collection_load_wipe_tower_preview);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::erase", XS_Slic3r__GUI___3DScene__GLVolume__Collection_erase);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::count", XS_Slic3r__GUI___3DScene__GLVolume__Collection_count);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::set_range", XS_Slic3r__GUI___3DScene__GLVolume__Collection_set_range);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::render_VBOs", XS_Slic3r__GUI___3DScene__GLVolume__Collection_render_VBOs);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::render_legacy", XS_Slic3r__GUI___3DScene__GLVolume__Collection_render_legacy);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::finalize_geometry", XS_Slic3r__GUI___3DScene__GLVolume__Collection_finalize_geometry);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::release_geometry", XS_Slic3r__GUI___3DScene__GLVolume__Collection_release_geometry);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::move_volume_up", XS_Slic3r__GUI___3DScene__GLVolume__Collection_move_volume_up);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::move_volume_down", XS_Slic3r__GUI___3DScene__GLVolume__Collection_move_volume_down);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVolume::Collection::arrayref", XS_Slic3r__GUI___3DScene__GLVolume__Collection_arrayref);
        newXS_deffile("Slic3r::GUI::_3DScene::_glew_init", XS_Slic3r__GUI___3DScene__glew_init);
        newXS_deffile("Slic3r::GUI::_3DScene::_load_print_toolpaths", XS_Slic3r__GUI___3DScene__load_print_toolpaths);
        newXS_deffile("Slic3r::GUI::_3DScene::_load_print_object_toolpaths", XS_Slic3r__GUI___3DScene__load_print_object_toolpaths);
        newXS_deffile("Slic3r::GUI::_3DScene::_load_wipe_tower_toolpaths", XS_Slic3r__GUI___3DScene__load_wipe_tower_toolpaths);
        newXS_deffile("Slic3r::GUI::disable_screensaver", XS_Slic3r__GUI_disable_screensaver);
        newXS_deffile("Slic3r::GUI::enable_screensaver", XS_Slic3r__GUI_enable_screensaver);
        newXS_deffile("Slic3r::GUI::debugged", XS_Slic3r__GUI_debugged);
        newXS_deffile("Slic3r::GUI::break_to_debugger", XS_Slic3r__GUI_break_to_debugger);
        newXS_deffile("Slic3r::Geometry::arrange", XS_Slic3r__Geometry_arrange);
        newXS_deffile("Slic3r::Geometry::directions_parallel", XS_Slic3r__Geometry_directions_parallel);
        newXS_deffile("Slic3r::Geometry::directions_parallel_within", XS_Slic3r__Geometry_directions_parallel_within);
        newXS_deffile("Slic3r::Geometry::convex_hull", XS_Slic3r__Geometry_convex_hull);
        newXS_deffile("Slic3r::Geometry::chained_path", XS_Slic3r__Geometry_chained_path);
        newXS_deffile("Slic3r::Geometry::chained_path_from", XS_Slic3r__Geometry_chained_path_from);
        newXS_deffile("Slic3r::Geometry::rad2deg", XS_Slic3r__Geometry_rad2deg);
        newXS_deffile("Slic3r::Geometry::rad2deg_dir", XS_Slic3r__Geometry_rad2deg_dir);
        newXS_deffile("Slic3r::Geometry::deg2rad", XS_Slic3r__Geometry_deg2rad);
        newXS_deffile("Slic3r::Geometry::simplify_polygons", XS_Slic3r__Geometry_simplify_polygons);
        cv = newXSproto_portable("Slic3r::Geometry::X", XS_Slic3r__Geometry__constant, file, "");
        XSANY.any_i32 = X;
        cv = newXSproto_portable("Slic3r::Geometry::Y", XS_Slic3r__Geometry__constant, file, "");
        XSANY.any_i32 = Y;
        cv = newXSproto_portable("Slic3r::Geometry::Z", XS_Slic3r__Geometry__constant, file, "");
        XSANY.any_i32 = Z;
        cv = newXSproto_portable("Slic3r::Geometry::_constant", XS_Slic3r__Geometry__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::GCode::Sender::new", XS_Slic3r__GCode__Sender_new);
        newXS_deffile("Slic3r::GCode::Sender::DESTROY", XS_Slic3r__GCode__Sender_DESTROY);
        newXS_deffile("Slic3r::GCode::Sender::connect", XS_Slic3r__GCode__Sender_connect);
        newXS_deffile("Slic3r::GCode::Sender::disconnect", XS_Slic3r__GCode__Sender_disconnect);
        newXS_deffile("Slic3r::GCode::Sender::is_connected", XS_Slic3r__GCode__Sender_is_connected);
        newXS_deffile("Slic3r::GCode::Sender::wait_connected", XS_Slic3r__GCode__Sender_wait_connected);
        newXS_deffile("Slic3r::GCode::Sender::queue_size", XS_Slic3r__GCode__Sender_queue_size);
        newXS_deffile("Slic3r::GCode::Sender::send", XS_Slic3r__GCode__Sender_send);
        newXS_deffile("Slic3r::GCode::Sender::pause_queue", XS_Slic3r__GCode__Sender_pause_queue);
        newXS_deffile("Slic3r::GCode::Sender::resume_queue", XS_Slic3r__GCode__Sender_resume_queue);
        newXS_deffile("Slic3r::GCode::Sender::purge_queue", XS_Slic3r__GCode__Sender_purge_queue);
        newXS_deffile("Slic3r::GCode::Sender::purge_log", XS_Slic3r__GCode__Sender_purge_log);
        newXS_deffile("Slic3r::GCode::Sender::getT", XS_Slic3r__GCode__Sender_getT);
        newXS_deffile("Slic3r::GCode::Sender::getB", XS_Slic3r__GCode__Sender_getB);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::new", XS_Slic3r__GCode__CoolingBuffer_new);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::DESTROY", XS_Slic3r__GCode__CoolingBuffer_DESTROY);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::gcodegen", XS_Slic3r__GCode__CoolingBuffer_gcodegen);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::process_layer", XS_Slic3r__GCode__CoolingBuffer_process_layer);
        newXS_deffile("Slic3r::GCode::new", XS_Slic3r__GCode_new);
        newXS_deffile("Slic3r::GCode::DESTROY", XS_Slic3r__GCode_DESTROY);
        newXS_deffile("Slic3r::GCode::do_export", XS_Slic3r__GCode_do_export);
        newXS_deffile("Slic3r::GCode::origin", XS_Slic3r__GCode_origin);
        newXS_deffile("Slic3r::GCode::set_origin", XS_Slic3r__GCode_set_origin);
        newXS_deffile("Slic3r::GCode::last_pos", XS_Slic3r__GCode_last_pos);
        newXS_deffile("Slic3r::GCode::layer_count", XS_Slic3r__GCode_layer_count);
        newXS_deffile("Slic3r::GCode::set_layer_count", XS_Slic3r__GCode_set_layer_count);
        newXS_deffile("Slic3r::GCode::set_extruders", XS_Slic3r__GCode_set_extruders);
        newXS_deffile("Slic3r::GCode::apply_print_config", XS_Slic3r__GCode_apply_print_config);
        newXS_deffile("Slic3r::GCode::config", XS_Slic3r__GCode_config);
        newXS_deffile("Slic3r::Flow::DESTROY", XS_Slic3r__Flow_DESTROY);
        newXS_deffile("Slic3r::Flow::_new", XS_Slic3r__Flow__new);
        newXS_deffile("Slic3r::Flow::set_height", XS_Slic3r__Flow_set_height);
        newXS_deffile("Slic3r::Flow::set_bridge", XS_Slic3r__Flow_set_bridge);
        newXS_deffile("Slic3r::Flow::clone", XS_Slic3r__Flow_clone);
        newXS_deffile("Slic3r::Flow::width", XS_Slic3r__Flow_width);
        newXS_deffile("Slic3r::Flow::height", XS_Slic3r__Flow_height);
        newXS_deffile("Slic3r::Flow::nozzle_diameter", XS_Slic3r__Flow_nozzle_diameter);
        newXS_deffile("Slic3r::Flow::bridge", XS_Slic3r__Flow_bridge);
        newXS_deffile("Slic3r::Flow::spacing", XS_Slic3r__Flow_spacing);
        newXS_deffile("Slic3r::Flow::spacing_to", XS_Slic3r__Flow_spacing_to);
        newXS_deffile("Slic3r::Flow::scaled_width", XS_Slic3r__Flow_scaled_width);
        newXS_deffile("Slic3r::Flow::scaled_spacing", XS_Slic3r__Flow_scaled_spacing);
        newXS_deffile("Slic3r::Flow::mm3_per_mm", XS_Slic3r__Flow_mm3_per_mm);
        newXS_deffile("Slic3r::Flow::_new_from_width", XS_Slic3r__Flow__new_from_width);
        newXS_deffile("Slic3r::Flow::_new_from_spacing", XS_Slic3r__Flow__new_from_spacing);
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_EXTERNAL_PERIMETER", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frExternalPerimeter;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_INFILL", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frInfill;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_PERIMETER", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frPerimeter;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_SOLID_INFILL", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frSolidInfill;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_SUPPORT_MATERIAL", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frSupportMaterial;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_SUPPORT_MATERIAL_INTERFACE", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frSupportMaterialInterface;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_TOP_SOLID_INFILL", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frTopSolidInfill;
        cv = newXSproto_portable("Slic3r::Flow::_constant", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::Filler::DESTROY", XS_Slic3r__Filler_DESTROY);
        newXS_deffile("Slic3r::Filler::set_bounding_box", XS_Slic3r__Filler_set_bounding_box);
        newXS_deffile("Slic3r::Filler::set_spacing", XS_Slic3r__Filler_set_spacing);
        newXS_deffile("Slic3r::Filler::spacing", XS_Slic3r__Filler_spacing);
        newXS_deffile("Slic3r::Filler::set_layer_id", XS_Slic3r__Filler_set_layer_id);
        newXS_deffile("Slic3r::Filler::set_z", XS_Slic3r__Filler_set_z);
        newXS_deffile("Slic3r::Filler::set_angle", XS_Slic3r__Filler_set_angle);
        newXS_deffile("Slic3r::Filler::set_link_max_length", XS_Slic3r__Filler_set_link_max_length);
        newXS_deffile("Slic3r::Filler::set_loop_clipping", XS_Slic3r__Filler_set_loop_clipping);
        newXS_deffile("Slic3r::Filler::use_bridge_flow", XS_Slic3r__Filler_use_bridge_flow);
        newXS_deffile("Slic3r::Filler::no_sort", XS_Slic3r__Filler_no_sort);
        newXS_deffile("Slic3r::Filler::set_density", XS_Slic3r__Filler_set_density);
        newXS_deffile("Slic3r::Filler::set_dont_connect", XS_Slic3r__Filler_set_dont_connect);
        newXS_deffile("Slic3r::Filler::set_dont_adjust", XS_Slic3r__Filler_set_dont_adjust);
        newXS_deffile("Slic3r::Filler::set_complete", XS_Slic3r__Filler_set_complete);
        newXS_deffile("Slic3r::Filler::_fill_surface", XS_Slic3r__Filler__fill_surface);
        newXS_deffile("Slic3r::Filler::new_from_type", XS_Slic3r__Filler_new_from_type);
        newXS_deffile("Slic3r::Filler::make_fill", XS_Slic3r__Filler_make_fill);
        newXS_deffile("Slic3r::ExtrusionSimulator::DESTROY", XS_Slic3r__ExtrusionSimulator_DESTROY);
        newXS_deffile("Slic3r::ExtrusionSimulator::_new", XS_Slic3r__ExtrusionSimulator__new);
        newXS_deffile("Slic3r::ExtrusionSimulator::clone", XS_Slic3r__ExtrusionSimulator_clone);
        newXS_deffile("Slic3r::ExtrusionSimulator::set_image_size", XS_Slic3r__ExtrusionSimulator_set_image_size);
        newXS_deffile("Slic3r::ExtrusionSimulator::set_viewport", XS_Slic3r__ExtrusionSimulator_set_viewport);
        newXS_deffile("Slic3r::ExtrusionSimulator::set_bounding_box", XS_Slic3r__ExtrusionSimulator_set_bounding_box);
        newXS_deffile("Slic3r::ExtrusionSimulator::reset_accumulator", XS_Slic3r__ExtrusionSimulator_reset_accumulator);
        newXS_deffile("Slic3r::ExtrusionSimulator::extrude_to_accumulator", XS_Slic3r__ExtrusionSimulator_extrude_to_accumulator);
        newXS_deffile("Slic3r::ExtrusionSimulator::evaluate_accumulator", XS_Slic3r__ExtrusionSimulator_evaluate_accumulator);
        newXS_deffile("Slic3r::ExtrusionSimulator::image_ptr", XS_Slic3r__ExtrusionSimulator_image_ptr);
        cv = newXSproto_portable("Slic3r::ExtrusionSimulator::EXTRSIM_DONT_SPREAD", XS_Slic3r__ExtrusionSimulator__constant, file, "");
        XSANY.any_i32 = ExtrusionSimulationDontSpread;
        cv = newXSproto_portable("Slic3r::ExtrusionSimulator::EXTRSIM_SIMPLE", XS_Slic3r__ExtrusionSimulator__constant, file, "");
        XSANY.any_i32 = ExtrusionSimulationSimple;
        cv = newXSproto_portable("Slic3r::ExtrusionSimulator::EXTRSIM_SPREAD_EXCESS", XS_Slic3r__ExtrusionSimulator__constant, file, "");
        XSANY.any_i32 = ExtrusionSimulationSpreadExcess;
        cv = newXSproto_portable("Slic3r::ExtrusionSimulator::EXTRSIM_SPREAD_FULL", XS_Slic3r__ExtrusionSimulator__constant, file, "");
        XSANY.any_i32 = ExtrusionSimulationSpreadFull;
        cv = newXSproto_portable("Slic3r::ExtrusionSimulator::EXTRSIM_SPREAD_NFULL", XS_Slic3r__ExtrusionSimulator__constant, file, "");
        XSANY.any_i32 = ExtrisopmSimulationSpreadNotOverfilled;
        cv = newXSproto_portable("Slic3r::ExtrusionSimulator::_constant", XS_Slic3r__ExtrusionSimulator__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::ExtrusionPath::DESTROY", XS_Slic3r__ExtrusionPath_DESTROY);
        newXS_deffile("Slic3r::ExtrusionPath::arrayref", XS_Slic3r__ExtrusionPath_arrayref);
        newXS_deffile("Slic3r::ExtrusionPath::pp", XS_Slic3r__ExtrusionPath_pp);
        newXS_deffile("Slic3r::ExtrusionPath::pop_back", XS_Slic3r__ExtrusionPath_pop_back);
        newXS_deffile("Slic3r::ExtrusionPath::reverse", XS_Slic3r__ExtrusionPath_reverse);
        newXS_deffile("Slic3r::ExtrusionPath::lines", XS_Slic3r__ExtrusionPath_lines);
        newXS_deffile("Slic3r::ExtrusionPath::first_point", XS_Slic3r__ExtrusionPath_first_point);
        newXS_deffile("Slic3r::ExtrusionPath::last_point", XS_Slic3r__ExtrusionPath_last_point);
        newXS_deffile("Slic3r::ExtrusionPath::clip_end", XS_Slic3r__ExtrusionPath_clip_end);
        newXS_deffile("Slic3r::ExtrusionPath::simplify", XS_Slic3r__ExtrusionPath_simplify);
        newXS_deffile("Slic3r::ExtrusionPath::length", XS_Slic3r__ExtrusionPath_length);
        newXS_deffile("Slic3r::ExtrusionPath::role", XS_Slic3r__ExtrusionPath_role);
        newXS_deffile("Slic3r::ExtrusionPath::is_bridge", XS_Slic3r__ExtrusionPath_is_bridge);
        newXS_deffile("Slic3r::ExtrusionPath::polygons_covered_by_width", XS_Slic3r__ExtrusionPath_polygons_covered_by_width);
        newXS_deffile("Slic3r::ExtrusionPath::polygons_covered_by_spacing", XS_Slic3r__ExtrusionPath_polygons_covered_by_spacing);
        newXS_deffile("Slic3r::ExtrusionPath::_new", XS_Slic3r__ExtrusionPath__new);
        newXS_deffile("Slic3r::ExtrusionPath::polyline", XS_Slic3r__ExtrusionPath_polyline);
        newXS_deffile("Slic3r::ExtrusionPath::mm3_per_mm", XS_Slic3r__ExtrusionPath_mm3_per_mm);
        newXS_deffile("Slic3r::ExtrusionPath::width", XS_Slic3r__ExtrusionPath_width);
        newXS_deffile("Slic3r::ExtrusionPath::height", XS_Slic3r__ExtrusionPath_height);
        newXS_deffile("Slic3r::ExtrusionPath::append", XS_Slic3r__ExtrusionPath_append);
        newXS_deffile("Slic3r::ExtrusionPath::intersect_expolygons", XS_Slic3r__ExtrusionPath_intersect_expolygons);
        newXS_deffile("Slic3r::ExtrusionPath::subtract_expolygons", XS_Slic3r__ExtrusionPath_subtract_expolygons);
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_BRIDGE", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erBridgeInfill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_EXTERNAL_PERIMETER", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erExternalPerimeter;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_FILL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erInternalInfill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_GAPFILL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erGapFill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_MIXED", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erMixed;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_NONE", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erNone;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_OVERHANG_PERIMETER", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erOverhangPerimeter;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_PERIMETER", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erPerimeter;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_SKIRT", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erSkirt;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_SOLIDFILL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erSolidInfill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_SUPPORTMATERIAL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erSupportMaterial;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_SUPPORTMATERIAL_INTERFACE", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erSupportMaterialInterface;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_TOPSOLIDFILL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erTopSolidInfill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::_constant", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::ExtrusionMultiPath::new", XS_Slic3r__ExtrusionMultiPath_new);
        newXS_deffile("Slic3r::ExtrusionMultiPath::DESTROY", XS_Slic3r__ExtrusionMultiPath_DESTROY);
        newXS_deffile("Slic3r::ExtrusionMultiPath::clone", XS_Slic3r__ExtrusionMultiPath_clone);
        newXS_deffile("Slic3r::ExtrusionMultiPath::reverse", XS_Slic3r__ExtrusionMultiPath_reverse);
        newXS_deffile("Slic3r::ExtrusionMultiPath::first_point", XS_Slic3r__ExtrusionMultiPath_first_point);
        newXS_deffile("Slic3r::ExtrusionMultiPath::last_point", XS_Slic3r__ExtrusionMultiPath_last_point);
        newXS_deffile("Slic3r::ExtrusionMultiPath::append", XS_Slic3r__ExtrusionMultiPath_append);
        newXS_deffile("Slic3r::ExtrusionMultiPath::length", XS_Slic3r__ExtrusionMultiPath_length);
        newXS_deffile("Slic3r::ExtrusionMultiPath::polygons_covered_by_width", XS_Slic3r__ExtrusionMultiPath_polygons_covered_by_width);
        newXS_deffile("Slic3r::ExtrusionMultiPath::polygons_covered_by_spacing", XS_Slic3r__ExtrusionMultiPath_polygons_covered_by_spacing);
        newXS_deffile("Slic3r::ExtrusionMultiPath::polyline", XS_Slic3r__ExtrusionMultiPath_polyline);
        newXS_deffile("Slic3r::ExtrusionMultiPath::arrayref", XS_Slic3r__ExtrusionMultiPath_arrayref);
        newXS_deffile("Slic3r::ExtrusionLoop::new", XS_Slic3r__ExtrusionLoop_new);
        newXS_deffile("Slic3r::ExtrusionLoop::DESTROY", XS_Slic3r__ExtrusionLoop_DESTROY);
        newXS_deffile("Slic3r::ExtrusionLoop::clone", XS_Slic3r__ExtrusionLoop_clone);
        newXS_deffile("Slic3r::ExtrusionLoop::reverse", XS_Slic3r__ExtrusionLoop_reverse);
        newXS_deffile("Slic3r::ExtrusionLoop::make_clockwise", XS_Slic3r__ExtrusionLoop_make_clockwise);
        newXS_deffile("Slic3r::ExtrusionLoop::make_counter_clockwise", XS_Slic3r__ExtrusionLoop_make_counter_clockwise);
        newXS_deffile("Slic3r::ExtrusionLoop::first_point", XS_Slic3r__ExtrusionLoop_first_point);
        newXS_deffile("Slic3r::ExtrusionLoop::last_point", XS_Slic3r__ExtrusionLoop_last_point);
        newXS_deffile("Slic3r::ExtrusionLoop::polygon", XS_Slic3r__ExtrusionLoop_polygon);
        newXS_deffile("Slic3r::ExtrusionLoop::append", XS_Slic3r__ExtrusionLoop_append);
        newXS_deffile("Slic3r::ExtrusionLoop::length", XS_Slic3r__ExtrusionLoop_length);
        newXS_deffile("Slic3r::ExtrusionLoop::split_at_vertex", XS_Slic3r__ExtrusionLoop_split_at_vertex);
        newXS_deffile("Slic3r::ExtrusionLoop::split_at", XS_Slic3r__ExtrusionLoop_split_at);
        newXS_deffile("Slic3r::ExtrusionLoop::clip_end", XS_Slic3r__ExtrusionLoop_clip_end);
        newXS_deffile("Slic3r::ExtrusionLoop::has_overhang_point", XS_Slic3r__ExtrusionLoop_has_overhang_point);
        newXS_deffile("Slic3r::ExtrusionLoop::role", XS_Slic3r__ExtrusionLoop_role);
        newXS_deffile("Slic3r::ExtrusionLoop::loop_role", XS_Slic3r__ExtrusionLoop_loop_role);
        newXS_deffile("Slic3r::ExtrusionLoop::polygons_covered_by_width", XS_Slic3r__ExtrusionLoop_polygons_covered_by_width);
        newXS_deffile("Slic3r::ExtrusionLoop::polygons_covered_by_spacing", XS_Slic3r__ExtrusionLoop_polygons_covered_by_spacing);
        newXS_deffile("Slic3r::ExtrusionLoop::arrayref", XS_Slic3r__ExtrusionLoop_arrayref);
        cv = newXSproto_portable("Slic3r::ExtrusionLoop::EXTRL_ROLE_CONTOUR_INTERNAL_PERIMETER", XS_Slic3r__ExtrusionLoop__constant, file, "");
        XSANY.any_i32 = elrContourInternalPerimeter;
        cv = newXSproto_portable("Slic3r::ExtrusionLoop::EXTRL_ROLE_DEFAULT", XS_Slic3r__ExtrusionLoop__constant, file, "");
        XSANY.any_i32 = elrDefault;
        cv = newXSproto_portable("Slic3r::ExtrusionLoop::EXTRL_ROLE_SKIRT", XS_Slic3r__ExtrusionLoop__constant, file, "");
        XSANY.any_i32 = elrSkirt;
        cv = newXSproto_portable("Slic3r::ExtrusionLoop::_constant", XS_Slic3r__ExtrusionLoop__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::ExtrusionPath::Collection::_new", XS_Slic3r__ExtrusionPath__Collection__new);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::DESTROY", XS_Slic3r__ExtrusionPath__Collection_DESTROY);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::clone", XS_Slic3r__ExtrusionPath__Collection_clone);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::reverse", XS_Slic3r__ExtrusionPath__Collection_reverse);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::clear", XS_Slic3r__ExtrusionPath__Collection_clear);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::chained_path", XS_Slic3r__ExtrusionPath__Collection_chained_path);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::chained_path_from", XS_Slic3r__ExtrusionPath__Collection_chained_path_from);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::first_point", XS_Slic3r__ExtrusionPath__Collection_first_point);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::last_point", XS_Slic3r__ExtrusionPath__Collection_last_point);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::count", XS_Slic3r__ExtrusionPath__Collection_count);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::items_count", XS_Slic3r__ExtrusionPath__Collection_items_count);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::flatten", XS_Slic3r__ExtrusionPath__Collection_flatten);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::min_mm3_per_mm", XS_Slic3r__ExtrusionPath__Collection_min_mm3_per_mm);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::empty", XS_Slic3r__ExtrusionPath__Collection_empty);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::orig_indices", XS_Slic3r__ExtrusionPath__Collection_orig_indices);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::polygons_covered_by_width", XS_Slic3r__ExtrusionPath__Collection_polygons_covered_by_width);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::polygons_covered_by_spacing", XS_Slic3r__ExtrusionPath__Collection_polygons_covered_by_spacing);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::arrayref", XS_Slic3r__ExtrusionPath__Collection_arrayref);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::append", XS_Slic3r__ExtrusionPath__Collection_append);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::no_sort", XS_Slic3r__ExtrusionPath__Collection_no_sort);
        newXS_deffile("Slic3r::ExPolygon::Collection::DESTROY", XS_Slic3r__ExPolygon__Collection_DESTROY);
        newXS_deffile("Slic3r::ExPolygon::Collection::clone", XS_Slic3r__ExPolygon__Collection_clone);
        newXS_deffile("Slic3r::ExPolygon::Collection::clear", XS_Slic3r__ExPolygon__Collection_clear);
        newXS_deffile("Slic3r::ExPolygon::Collection::scale", XS_Slic3r__ExPolygon__Collection_scale);
        newXS_deffile("Slic3r::ExPolygon::Collection::translate", XS_Slic3r__ExPolygon__Collection_translate);
        newXS_deffile("Slic3r::ExPolygon::Collection::rotate", XS_Slic3r__ExPolygon__Collection_rotate);
        newXS_deffile("Slic3r::ExPolygon::Collection::count", XS_Slic3r__ExPolygon__Collection_count);
        newXS_deffile("Slic3r::ExPolygon::Collection::contains_point", XS_Slic3r__ExPolygon__Collection_contains_point);
        newXS_deffile("Slic3r::ExPolygon::Collection::contains_line", XS_Slic3r__ExPolygon__Collection_contains_line);
        newXS_deffile("Slic3r::ExPolygon::Collection::contains_polyline", XS_Slic3r__ExPolygon__Collection_contains_polyline);
        newXS_deffile("Slic3r::ExPolygon::Collection::simplify", XS_Slic3r__ExPolygon__Collection_simplify);
        newXS_deffile("Slic3r::ExPolygon::Collection::polygons", XS_Slic3r__ExPolygon__Collection_polygons);
        newXS_deffile("Slic3r::ExPolygon::Collection::convex_hull", XS_Slic3r__ExPolygon__Collection_convex_hull);
        newXS_deffile("Slic3r::ExPolygon::Collection::new", XS_Slic3r__ExPolygon__Collection_new);
        newXS_deffile("Slic3r::ExPolygon::Collection::arrayref", XS_Slic3r__ExPolygon__Collection_arrayref);
        newXS_deffile("Slic3r::ExPolygon::Collection::pp", XS_Slic3r__ExPolygon__Collection_pp);
        newXS_deffile("Slic3r::ExPolygon::Collection::append", XS_Slic3r__ExPolygon__Collection_append);
        newXS_deffile("Slic3r::ExPolygon::DESTROY", XS_Slic3r__ExPolygon_DESTROY);
        newXS_deffile("Slic3r::ExPolygon::clone", XS_Slic3r__ExPolygon_clone);
        newXS_deffile("Slic3r::ExPolygon::arrayref", XS_Slic3r__ExPolygon_arrayref);
        newXS_deffile("Slic3r::ExPolygon::pp", XS_Slic3r__ExPolygon_pp);
        newXS_deffile("Slic3r::ExPolygon::contour", XS_Slic3r__ExPolygon_contour);
        newXS_deffile("Slic3r::ExPolygon::holes", XS_Slic3r__ExPolygon_holes);
        newXS_deffile("Slic3r::ExPolygon::scale", XS_Slic3r__ExPolygon_scale);
        newXS_deffile("Slic3r::ExPolygon::translate", XS_Slic3r__ExPolygon_translate);
        newXS_deffile("Slic3r::ExPolygon::area", XS_Slic3r__ExPolygon_area);
        newXS_deffile("Slic3r::ExPolygon::is_valid", XS_Slic3r__ExPolygon_is_valid);
        newXS_deffile("Slic3r::ExPolygon::contains_line", XS_Slic3r__ExPolygon_contains_line);
        newXS_deffile("Slic3r::ExPolygon::contains_polyline", XS_Slic3r__ExPolygon_contains_polyline);
        newXS_deffile("Slic3r::ExPolygon::contains_point", XS_Slic3r__ExPolygon_contains_point);
        newXS_deffile("Slic3r::ExPolygon::simplify", XS_Slic3r__ExPolygon_simplify);
        newXS_deffile("Slic3r::ExPolygon::simplify_p", XS_Slic3r__ExPolygon_simplify_p);
        newXS_deffile("Slic3r::ExPolygon::medial_axis", XS_Slic3r__ExPolygon_medial_axis);
        newXS_deffile("Slic3r::ExPolygon::get_trapezoids", XS_Slic3r__ExPolygon_get_trapezoids);
        newXS_deffile("Slic3r::ExPolygon::get_trapezoids2", XS_Slic3r__ExPolygon_get_trapezoids2);
        newXS_deffile("Slic3r::ExPolygon::triangulate", XS_Slic3r__ExPolygon_triangulate);
        newXS_deffile("Slic3r::ExPolygon::triangulate_pp", XS_Slic3r__ExPolygon_triangulate_pp);
        newXS_deffile("Slic3r::ExPolygon::new", XS_Slic3r__ExPolygon_new);
        newXS_deffile("Slic3r::ExPolygon::rotate", XS_Slic3r__ExPolygon_rotate);
        newXS_deffile("Slic3r::Config::new", XS_Slic3r__Config_new);
        newXS_deffile("Slic3r::Config::DESTROY", XS_Slic3r__Config_DESTROY);
        newXS_deffile("Slic3r::Config::has", XS_Slic3r__Config_has);
        newXS_deffile("Slic3r::Config::as_hash", XS_Slic3r__Config_as_hash);
        newXS_deffile("Slic3r::Config::get", XS_Slic3r__Config_get);
        newXS_deffile("Slic3r::Config::get_at", XS_Slic3r__Config_get_at);
        newXS_deffile("Slic3r::Config::set", XS_Slic3r__Config_set);
        newXS_deffile("Slic3r::Config::set_deserialize", XS_Slic3r__Config_set_deserialize);
        newXS_deffile("Slic3r::Config::set_ifndef", XS_Slic3r__Config_set_ifndef);
        newXS_deffile("Slic3r::Config::serialize", XS_Slic3r__Config_serialize);
        newXS_deffile("Slic3r::Config::get_abs_value", XS_Slic3r__Config_get_abs_value);
        newXS_deffile("Slic3r::Config::get_abs_value_over", XS_Slic3r__Config_get_abs_value_over);
        newXS_deffile("Slic3r::Config::apply", XS_Slic3r__Config_apply);
        newXS_deffile("Slic3r::Config::diff", XS_Slic3r__Config_diff);
        newXS_deffile("Slic3r::Config::equals", XS_Slic3r__Config_equals);
        newXS_deffile("Slic3r::Config::apply_static", XS_Slic3r__Config_apply_static);
        newXS_deffile("Slic3r::Config::get_keys", XS_Slic3r__Config_get_keys);
        newXS_deffile("Slic3r::Config::erase", XS_Slic3r__Config_erase);
        newXS_deffile("Slic3r::Config::normalize", XS_Slic3r__Config_normalize);
        newXS_deffile("Slic3r::Config::setenv", XS_Slic3r__Config_setenv);
        newXS_deffile("Slic3r::Config::min_object_distance", XS_Slic3r__Config_min_object_distance);
        newXS_deffile("Slic3r::Config::_load", XS_Slic3r__Config__load);
        newXS_deffile("Slic3r::Config::_load_from_gcode", XS_Slic3r__Config__load_from_gcode);
        newXS_deffile("Slic3r::Config::_save", XS_Slic3r__Config__save);
        newXS_deffile("Slic3r::Config::Static::new_GCodeConfig", XS_Slic3r__Config__Static_new_GCodeConfig);
        newXS_deffile("Slic3r::Config::Static::new_PrintConfig", XS_Slic3r__Config__Static_new_PrintConfig);
        newXS_deffile("Slic3r::Config::Static::new_PrintObjectConfig", XS_Slic3r__Config__Static_new_PrintObjectConfig);
        newXS_deffile("Slic3r::Config::Static::new_PrintRegionConfig", XS_Slic3r__Config__Static_new_PrintRegionConfig);
        newXS_deffile("Slic3r::Config::Static::new_FullPrintConfig", XS_Slic3r__Config__Static_new_FullPrintConfig);
        newXS_deffile("Slic3r::Config::Static::DESTROY", XS_Slic3r__Config__Static_DESTROY);
        newXS_deffile("Slic3r::Config::Static::has", XS_Slic3r__Config__Static_has);
        newXS_deffile("Slic3r::Config::Static::as_hash", XS_Slic3r__Config__Static_as_hash);
        newXS_deffile("Slic3r::Config::Static::get", XS_Slic3r__Config__Static_get);
        newXS_deffile("Slic3r::Config::Static::get_at", XS_Slic3r__Config__Static_get_at);
        newXS_deffile("Slic3r::Config::Static::set", XS_Slic3r__Config__Static_set);
        newXS_deffile("Slic3r::Config::Static::set_deserialize", XS_Slic3r__Config__Static_set_deserialize);
        newXS_deffile("Slic3r::Config::Static::set_ifndef", XS_Slic3r__Config__Static_set_ifndef);
        newXS_deffile("Slic3r::Config::Static::serialize", XS_Slic3r__Config__Static_serialize);
        newXS_deffile("Slic3r::Config::Static::get_abs_value", XS_Slic3r__Config__Static_get_abs_value);
        newXS_deffile("Slic3r::Config::Static::get_abs_value_over", XS_Slic3r__Config__Static_get_abs_value_over);
        newXS_deffile("Slic3r::Config::Static::apply_static", XS_Slic3r__Config__Static_apply_static);
        newXS_deffile("Slic3r::Config::Static::apply_dynamic", XS_Slic3r__Config__Static_apply_dynamic);
        newXS_deffile("Slic3r::Config::Static::get_keys", XS_Slic3r__Config__Static_get_keys);
        newXS_deffile("Slic3r::Config::Static::get_extrusion_axis", XS_Slic3r__Config__Static_get_extrusion_axis);
        newXS_deffile("Slic3r::Config::Static::setenv", XS_Slic3r__Config__Static_setenv);
        newXS_deffile("Slic3r::Config::Static::min_object_distance", XS_Slic3r__Config__Static_min_object_distance);
        newXS_deffile("Slic3r::Config::Static::_load", XS_Slic3r__Config__Static__load);
        newXS_deffile("Slic3r::Config::Static::_load_from_gcode", XS_Slic3r__Config__Static__load_from_gcode);
        newXS_deffile("Slic3r::Config::Static::_save", XS_Slic3r__Config__Static__save);
        newXS_deffile("Slic3r::Config::print_config_def", XS_Slic3r__Config_print_config_def);
        cv = newXS_deffile("Slic3r::Geometry::Clipper::JT_MITER", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = jtMiter;
        cv = newXS_deffile("Slic3r::Geometry::Clipper::JT_ROUND", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = jtRound;
        cv = newXS_deffile("Slic3r::Geometry::Clipper::JT_SQUARE", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = jtSquare;
        cv = newXS_deffile("Slic3r::Geometry::Clipper::_constant", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::Geometry::Clipper::offset", XS_Slic3r__Geometry__Clipper_offset);
        newXS_deffile("Slic3r::Geometry::Clipper::offset_ex", XS_Slic3r__Geometry__Clipper_offset_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::offset2", XS_Slic3r__Geometry__Clipper_offset2);
        newXS_deffile("Slic3r::Geometry::Clipper::offset2_ex", XS_Slic3r__Geometry__Clipper_offset2_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::diff", XS_Slic3r__Geometry__Clipper_diff);
        newXS_deffile("Slic3r::Geometry::Clipper::diff_ex", XS_Slic3r__Geometry__Clipper_diff_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::diff_pl", XS_Slic3r__Geometry__Clipper_diff_pl);
        newXS_deffile("Slic3r::Geometry::Clipper::intersection", XS_Slic3r__Geometry__Clipper_intersection);
        newXS_deffile("Slic3r::Geometry::Clipper::intersection_ex", XS_Slic3r__Geometry__Clipper_intersection_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::intersection_pl", XS_Slic3r__Geometry__Clipper_intersection_pl);
        newXS_deffile("Slic3r::Geometry::Clipper::union", XS_Slic3r__Geometry__Clipper_union);
        newXS_deffile("Slic3r::Geometry::Clipper::union_ex", XS_Slic3r__Geometry__Clipper_union_ex);
        newXS_deffile("Slic3r::BridgeDetector::DESTROY", XS_Slic3r__BridgeDetector_DESTROY);
        newXS_deffile("Slic3r::BridgeDetector::detect_angle", XS_Slic3r__BridgeDetector_detect_angle);
        newXS_deffile("Slic3r::BridgeDetector::coverage", XS_Slic3r__BridgeDetector_coverage);
        newXS_deffile("Slic3r::BridgeDetector::coverage_by_angle", XS_Slic3r__BridgeDetector_coverage_by_angle);
        newXS_deffile("Slic3r::BridgeDetector::unsupported_edges", XS_Slic3r__BridgeDetector_unsupported_edges);
        newXS_deffile("Slic3r::BridgeDetector::unsupported_edges_by_angle", XS_Slic3r__BridgeDetector_unsupported_edges_by_angle);
        newXS_deffile("Slic3r::BridgeDetector::angle", XS_Slic3r__BridgeDetector_angle);
        newXS_deffile("Slic3r::BridgeDetector::resolution", XS_Slic3r__BridgeDetector_resolution);
        newXS_deffile("Slic3r::BridgeDetector::new", XS_Slic3r__BridgeDetector_new);
        newXS_deffile("Slic3r::BridgeDetector::new_expolygons", XS_Slic3r__BridgeDetector_new_expolygons);
        newXS_deffile("Slic3r::Geometry::BoundingBox::new", XS_Slic3r__Geometry__BoundingBox_new);
        newXS_deffile("Slic3r::Geometry::BoundingBox::DESTROY", XS_Slic3r__Geometry__BoundingBox_DESTROY);
        newXS_deffile("Slic3r::Geometry::BoundingBox::clone", XS_Slic3r__Geometry__BoundingBox_clone);
        newXS_deffile("Slic3r::Geometry::BoundingBox::merge", XS_Slic3r__Geometry__BoundingBox_merge);
        newXS_deffile("Slic3r::Geometry::BoundingBox::merge_point", XS_Slic3r__Geometry__BoundingBox_merge_point);
        newXS_deffile("Slic3r::Geometry::BoundingBox::scale", XS_Slic3r__Geometry__BoundingBox_scale);
        newXS_deffile("Slic3r::Geometry::BoundingBox::translate", XS_Slic3r__Geometry__BoundingBox_translate);
        newXS_deffile("Slic3r::Geometry::BoundingBox::offset", XS_Slic3r__Geometry__BoundingBox_offset);
        newXS_deffile("Slic3r::Geometry::BoundingBox::contains_point", XS_Slic3r__Geometry__BoundingBox_contains_point);
        newXS_deffile("Slic3r::Geometry::BoundingBox::overlap", XS_Slic3r__Geometry__BoundingBox_overlap);
        newXS_deffile("Slic3r::Geometry::BoundingBox::polygon", XS_Slic3r__Geometry__BoundingBox_polygon);
        newXS_deffile("Slic3r::Geometry::BoundingBox::size", XS_Slic3r__Geometry__BoundingBox_size);
        newXS_deffile("Slic3r::Geometry::BoundingBox::center", XS_Slic3r__Geometry__BoundingBox_center);
        newXS_deffile("Slic3r::Geometry::BoundingBox::empty", XS_Slic3r__Geometry__BoundingBox_empty);
        newXS_deffile("Slic3r::Geometry::BoundingBox::radius", XS_Slic3r__Geometry__BoundingBox_radius);
        newXS_deffile("Slic3r::Geometry::BoundingBox::min_point", XS_Slic3r__Geometry__BoundingBox_min_point);
        newXS_deffile("Slic3r::Geometry::BoundingBox::max_point", XS_Slic3r__Geometry__BoundingBox_max_point);
        newXS_deffile("Slic3r::Geometry::BoundingBox::x_min", XS_Slic3r__Geometry__BoundingBox_x_min);
        newXS_deffile("Slic3r::Geometry::BoundingBox::x_max", XS_Slic3r__Geometry__BoundingBox_x_max);
        newXS_deffile("Slic3r::Geometry::BoundingBox::y_min", XS_Slic3r__Geometry__BoundingBox_y_min);
        newXS_deffile("Slic3r::Geometry::BoundingBox::y_max", XS_Slic3r__Geometry__BoundingBox_y_max);
        newXS_deffile("Slic3r::Geometry::BoundingBox::serialize", XS_Slic3r__Geometry__BoundingBox_serialize);
        newXS_deffile("Slic3r::Geometry::BoundingBox::defined", XS_Slic3r__Geometry__BoundingBox_defined);
        newXS_deffile("Slic3r::Geometry::BoundingBox::new_from_points", XS_Slic3r__Geometry__BoundingBox_new_from_points);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::new", XS_Slic3r__Geometry__BoundingBoxf_new);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::DESTROY", XS_Slic3r__Geometry__BoundingBoxf_DESTROY);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::clone", XS_Slic3r__Geometry__BoundingBoxf_clone);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::merge", XS_Slic3r__Geometry__BoundingBoxf_merge);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::merge_point", XS_Slic3r__Geometry__BoundingBoxf_merge_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::scale", XS_Slic3r__Geometry__BoundingBoxf_scale);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::translate", XS_Slic3r__Geometry__BoundingBoxf_translate);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::size", XS_Slic3r__Geometry__BoundingBoxf_size);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::center", XS_Slic3r__Geometry__BoundingBoxf_center);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::radius", XS_Slic3r__Geometry__BoundingBoxf_radius);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::empty", XS_Slic3r__Geometry__BoundingBoxf_empty);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::min_point", XS_Slic3r__Geometry__BoundingBoxf_min_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::max_point", XS_Slic3r__Geometry__BoundingBoxf_max_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::x_min", XS_Slic3r__Geometry__BoundingBoxf_x_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::x_max", XS_Slic3r__Geometry__BoundingBoxf_x_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::y_min", XS_Slic3r__Geometry__BoundingBoxf_y_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::y_max", XS_Slic3r__Geometry__BoundingBoxf_y_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::set_x_min", XS_Slic3r__Geometry__BoundingBoxf_set_x_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::set_x_max", XS_Slic3r__Geometry__BoundingBoxf_set_x_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::set_y_min", XS_Slic3r__Geometry__BoundingBoxf_set_y_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::set_y_max", XS_Slic3r__Geometry__BoundingBoxf_set_y_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::serialize", XS_Slic3r__Geometry__BoundingBoxf_serialize);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::defined", XS_Slic3r__Geometry__BoundingBoxf_defined);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::new_from_points", XS_Slic3r__Geometry__BoundingBoxf_new_from_points);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::new", XS_Slic3r__Geometry__BoundingBoxf3_new);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::DESTROY", XS_Slic3r__Geometry__BoundingBoxf3_DESTROY);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::clone", XS_Slic3r__Geometry__BoundingBoxf3_clone);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::merge", XS_Slic3r__Geometry__BoundingBoxf3_merge);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::merge_point", XS_Slic3r__Geometry__BoundingBoxf3_merge_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::scale", XS_Slic3r__Geometry__BoundingBoxf3_scale);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::translate", XS_Slic3r__Geometry__BoundingBoxf3_translate);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::offset", XS_Slic3r__Geometry__BoundingBoxf3_offset);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::contains_point", XS_Slic3r__Geometry__BoundingBoxf3_contains_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::size", XS_Slic3r__Geometry__BoundingBoxf3_size);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::center", XS_Slic3r__Geometry__BoundingBoxf3_center);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::radius", XS_Slic3r__Geometry__BoundingBoxf3_radius);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::empty", XS_Slic3r__Geometry__BoundingBoxf3_empty);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::min_point", XS_Slic3r__Geometry__BoundingBoxf3_min_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::max_point", XS_Slic3r__Geometry__BoundingBoxf3_max_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::x_min", XS_Slic3r__Geometry__BoundingBoxf3_x_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::x_max", XS_Slic3r__Geometry__BoundingBoxf3_x_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::y_min", XS_Slic3r__Geometry__BoundingBoxf3_y_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::y_max", XS_Slic3r__Geometry__BoundingBoxf3_y_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::z_min", XS_Slic3r__Geometry__BoundingBoxf3_z_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::z_max", XS_Slic3r__Geometry__BoundingBoxf3_z_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::serialize", XS_Slic3r__Geometry__BoundingBoxf3_serialize);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::defined", XS_Slic3r__Geometry__BoundingBoxf3_defined);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

